{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/nozzles/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n    const status = searchParams.get('status')\n\n    const params: any[] = []\n    let query: string\n\n    if (branchId) {\n      params.push(branchId)\n      const branchIdx = params.length\n      query = `\n        SELECT n.id, n.branch_id, n.dispenser_id, n.nozzle_number, n.status, \n               n.initial_meter_reading, n.item_id, n.tank_id, n.created_at, n.updated_at,\n               d.dispenser_number, COALESCE(i.item_name, 'Unknown') as item_name, \n               COALESCE(i.item_name, 'Unknown') as fuel_type,\n               t.tank_name,\n               COALESCE(\n                 (SELECT sr.closing_reading \n                  FROM shift_readings sr \n                  JOIN shifts s ON sr.shift_id = s.id \n                  WHERE sr.nozzle_id = n.id AND s.status = 'completed' \n                  ORDER BY s.end_time DESC NULLS LAST, s.created_at DESC \n                  LIMIT 1), \n                 n.initial_meter_reading, \n                 0\n               ) as current_meter_reading\n        FROM nozzles n\n        LEFT JOIN dispensers d ON n.dispenser_id = d.id\n        LEFT JOIN items i ON n.item_id = i.id\n        LEFT JOIN tanks t ON n.tank_id = t.id\n        LEFT JOIN branch_items bi ON bi.item_id = n.item_id AND bi.branch_id = $${branchIdx}\n        WHERE n.branch_id = $${branchIdx}`\n    } else {\n      query = `\n        SELECT n.id, n.branch_id, n.dispenser_id, n.nozzle_number, n.status, \n               n.initial_meter_reading, n.item_id, n.tank_id, n.created_at, n.updated_at,\n               d.dispenser_number, COALESCE(i.item_name, 'Unknown') as item_name, \n               COALESCE(i.item_name, 'Unknown') as fuel_type,\n               t.tank_name,\n               COALESCE(\n                 (SELECT sr.closing_reading \n                  FROM shift_readings sr \n                  JOIN shifts s ON sr.shift_id = s.id \n                  WHERE sr.nozzle_id = n.id AND s.status = 'completed' \n                  ORDER BY s.end_time DESC NULLS LAST, s.created_at DESC \n                  LIMIT 1), \n                 n.initial_meter_reading, \n                 0\n               ) as current_meter_reading\n        FROM nozzles n\n        LEFT JOIN dispensers d ON n.dispenser_id = d.id\n        LEFT JOIN items i ON n.item_id = i.id\n        LEFT JOIN tanks t ON n.tank_id = t.id\n        WHERE 1=1`\n    }\n\n    if (status) {\n      params.push(status)\n      query += ` AND n.status = $${params.length}`\n    }\n\n    query += ' ORDER BY d.dispenser_number, n.nozzle_number'\n\n    const result = await pool.query(query, params)\n\n    return NextResponse.json({\n      success: true,\n      data: result.rows\n    })\n\n  } catch (error: any) {\n    console.error(\"Error fetching nozzles:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch nozzles\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { \n      branch_id, \n      dispenser_id, \n      nozzle_number, \n      status,\n      initial_meter_reading,\n      item_id,\n      tank_id\n    } = body\n\n    if (!branch_id || !dispenser_id || !nozzle_number) {\n      return NextResponse.json(\n        { error: \"branch_id, dispenser_id, and nozzle_number are required\" },\n        { status: 400 }\n      )\n    }\n\n    if (!item_id && !tank_id) {\n      return NextResponse.json(\n        { error: \"Either item_id or tank_id is required - select a fuel type or tank\" },\n        { status: 400 }\n      )\n    }\n\n    const result = await pool.query(\n      `INSERT INTO nozzles (branch_id, dispenser_id, nozzle_number, status, initial_meter_reading, item_id, tank_id)\n       VALUES ($1, $2, $3, $4, $5, $6, $7)\n       RETURNING *`,\n      [branch_id, dispenser_id, nozzle_number, status || 'active', initial_meter_reading || 0, item_id, tank_id]\n    )\n\n    return NextResponse.json({\n      success: true,\n      data: result.rows[0]\n    })\n\n  } catch (error: any) {\n    console.error(\"Error creating nozzle:\", error)\n    return NextResponse.json(\n      { error: \"Failed to create nozzle\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function PUT(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { \n      id,\n      dispenser_id,\n      nozzle_number, \n      status,\n      initial_meter_reading,\n      item_id,\n      tank_id\n    } = body\n\n    if (!id) {\n      return NextResponse.json(\n        { error: \"Nozzle id is required\" },\n        { status: 400 }\n      )\n    }\n\n    const result = await pool.query(\n      `UPDATE nozzles \n       SET dispenser_id = COALESCE($2, dispenser_id),\n           nozzle_number = COALESCE($3, nozzle_number),\n           status = COALESCE($4, status),\n           initial_meter_reading = COALESCE($5, initial_meter_reading),\n           item_id = COALESCE($6, item_id),\n           tank_id = COALESCE($7, tank_id),\n           updated_at = NOW()\n       WHERE id = $1\n       RETURNING *`,\n      [id, dispenser_id, nozzle_number, status, initial_meter_reading, item_id, tank_id]\n    )\n\n    if (result.rows.length === 0) {\n      return NextResponse.json(\n        { error: \"Nozzle not found\" },\n        { status: 404 }\n      )\n    }\n\n    return NextResponse.json({\n      success: true,\n      data: result.rows[0]\n    })\n\n  } catch (error: any) {\n    console.error(\"Error updating nozzle:\", error)\n    return NextResponse.json(\n      { error: \"Failed to update nozzle\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    let id = searchParams.get('id')\n\n    // Also support JSON body for DELETE\n    if (!id) {\n      try {\n        const body = await request.json()\n        id = body.id\n      } catch {}\n    }\n\n    if (!id) {\n      return NextResponse.json(\n        { error: \"Nozzle id is required\" },\n        { status: 400 }\n      )\n    }\n\n    const result = await pool.query(\n      'DELETE FROM nozzles WHERE id = $1 RETURNING *',\n      [id]\n    )\n\n    if (result.rows.length === 0) {\n      return NextResponse.json(\n        { error: \"Nozzle not found\" },\n        { status: 404 }\n      )\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: \"Nozzle deleted successfully\"\n    })\n\n  } catch (error: any) {\n    console.error(\"Error deleting nozzle:\", error)\n    return NextResponse.json(\n      { error: \"Failed to delete nozzle\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}