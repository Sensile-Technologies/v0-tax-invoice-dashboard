module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/pg [external] (pg, esm_import)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

const mod = await __turbopack_context__.y("pg");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/http2 [external] (http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/querystring [external] (querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}),
"[project]/lib/whatsapp-service.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatDSSRMessage",
    ()=>formatDSSRMessage,
    "sendDSSRToDirectors",
    ()=>sendDSSRToDirectors,
    "sendWhatsAppMessage",
    ()=>sendWhatsAppMessage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$twilio$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/twilio/lib/index.js [app-route] (ecmascript)");
;
const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const whatsappNumber = process.env.TWILIO_WHATSAPP_NUMBER;
let twilioClient = null;
function getClient() {
    if (!twilioClient) {
        if (!accountSid || !authToken) {
            throw new Error('Twilio credentials not configured');
        }
        twilioClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$twilio$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(accountSid, authToken);
    }
    return twilioClient;
}
function formatDSSRMessage(summary) {
    const formatCurrency = (amount)=>`KES ${amount.toLocaleString('en-KE', {
            minimumFractionDigits: 2
        })}`;
    const formatVolume = (vol)=>`${vol.toLocaleString('en-KE', {
            minimumFractionDigits: 2
        })} L`;
    let message = `*DSSR - ${summary.branchName}*\n`;
    message += `Date: ${summary.date}\n`;
    message += `Shift: ${summary.shiftType}\n`;
    message += `Attendant: ${summary.attendantName}\n`;
    message += `─────────────────\n`;
    message += `*Sales Summary*\n`;
    message += `Total Sales: ${formatCurrency(summary.totalSales)}\n`;
    message += `Total Volume: ${formatVolume(summary.totalVolume)}\n`;
    message += `─────────────────\n`;
    message += `*Collections*\n`;
    message += `Cash: ${formatCurrency(summary.cashCollected)}\n`;
    message += `M-Pesa: ${formatCurrency(summary.mpesaCollected)}\n`;
    message += `Credit: ${formatCurrency(summary.creditSales)}\n`;
    message += `─────────────────\n`;
    if (summary.productBreakdown.length > 0) {
        message += `*Product Breakdown*\n`;
        for (const product of summary.productBreakdown){
            message += `${product.product}: ${formatVolume(product.volume)} (${formatCurrency(product.amount)})\n`;
        }
        message += `─────────────────\n`;
    }
    const varianceStatus = summary.variance >= 0 ? '✅' : '⚠️';
    message += `*Variance: ${varianceStatus} ${formatCurrency(summary.variance)}*\n`;
    message += `─────────────────\n`;
    message += `_Sent automatically by Flow360_`;
    return message;
}
async function sendWhatsAppMessage(to, message) {
    try {
        if (!whatsappNumber) {
            throw new Error('Twilio WhatsApp number not configured');
        }
        const client = getClient();
        const toNumber = to.startsWith('+') ? to : `+${to}`;
        const fromNumber = whatsappNumber.startsWith('+') ? whatsappNumber : `+${whatsappNumber}`;
        const result = await client.messages.create({
            from: `whatsapp:${fromNumber}`,
            to: `whatsapp:${toNumber}`,
            body: message
        });
        console.log(`[WhatsApp] Message sent successfully. SID: ${result.sid}`);
        return {
            success: true,
            messageId: result.sid
        };
    } catch (error) {
        console.error('[WhatsApp] Error sending message:', error.message);
        return {
            success: false,
            error: error.message || 'Failed to send WhatsApp message'
        };
    }
}
async function sendDSSRToDirectors(summary, directorNumbers) {
    const message = formatDSSRMessage(summary);
    const results = [];
    for (const number of directorNumbers){
        const result = await sendWhatsAppMessage(number, message);
        results.push({
            number,
            success: result.success,
            error: result.error
        });
    }
    const allSuccess = results.every((r)=>r.success);
    return {
        success: allSuccess,
        results
    };
}
}),
"[project]/app/api/shifts/reconcile/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/pg [external] (pg, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$whatsapp$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/whatsapp-service.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__
]);
[__TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
const pool = new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__["Pool"]({
    connectionString: process.env.DATABASE_URL
});
async function POST(request) {
    const client = await pool.connect();
    try {
        const body = await request.json();
        const { shift_id, attendant_collections, expenses, banking, notes } = body;
        if (!shift_id) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "shift_id is required"
            }, {
                status: 400
            });
        }
        await client.query('BEGIN');
        const shiftCheck = await client.query(`SELECT s.*, b.vendor_id FROM shifts s
       JOIN branches b ON s.branch_id = b.id
       WHERE s.id = $1`, [
            shift_id
        ]);
        if (shiftCheck.rows.length === 0) {
            await client.query('ROLLBACK');
            client.release();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Shift not found"
            }, {
                status: 404
            });
        }
        const shift = shiftCheck.rows[0];
        const branchId = shift.branch_id;
        const vendorId = shift.vendor_id;
        if (shift.reconciliation_status === 'reconciled') {
            await client.query('ROLLBACK');
            client.release();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Shift has already been reconciled"
            }, {
                status: 400
            });
        }
        // Collections, expenses, and banking are now optional for reconciliation
        await client.query(`DELETE FROM attendant_collections WHERE shift_id = $1`, [
            shift_id
        ]);
        if (attendant_collections && attendant_collections.length > 0) {
            for (const collection of attendant_collections){
                if (collection.attendant_id && collection.payments && Array.isArray(collection.payments)) {
                    for (const payment of collection.payments){
                        if (payment.payment_method && payment.amount > 0) {
                            await client.query(`INSERT INTO attendant_collections (shift_id, branch_id, staff_id, payment_method, amount, is_app_payment)
                 VALUES ($1, $2, $3, $4, $5, false)`, [
                                shift_id,
                                branchId,
                                collection.attendant_id,
                                payment.payment_method,
                                payment.amount
                            ]);
                        }
                    }
                }
            }
        }
        await client.query(`DELETE FROM shift_expenses WHERE shift_id = $1`, [
            shift_id
        ]);
        if (expenses && expenses.length > 0) {
            for (const expense of expenses){
                if (expense.expense_account_id && expense.amount > 0) {
                    const accountCheck = await client.query('SELECT id FROM expense_accounts WHERE id = $1 AND vendor_id = $2', [
                        expense.expense_account_id,
                        vendorId
                    ]);
                    if (accountCheck.rows.length === 0) {
                        console.warn(`[Reconcile] Skipping invalid expense account ${expense.expense_account_id}`);
                        continue;
                    }
                    await client.query(`INSERT INTO shift_expenses (shift_id, branch_id, expense_account_id, amount, description)
             VALUES ($1, $2, $3, $4, $5)`, [
                        shift_id,
                        branchId,
                        expense.expense_account_id,
                        expense.amount,
                        expense.description || null
                    ]);
                }
            }
        }
        await client.query(`DELETE FROM shift_banking WHERE shift_id = $1`, [
            shift_id
        ]);
        if (banking && banking.length > 0) {
            for (const entry of banking){
                if (entry.banking_account_id && entry.amount > 0) {
                    const accountCheck = await client.query('SELECT id FROM banking_accounts WHERE id = $1 AND vendor_id = $2', [
                        entry.banking_account_id,
                        vendorId
                    ]);
                    if (accountCheck.rows.length === 0) {
                        console.warn(`[Reconcile] Skipping invalid banking account ${entry.banking_account_id}`);
                        continue;
                    }
                    await client.query(`INSERT INTO shift_banking (shift_id, banking_account_id, amount, notes)
             VALUES ($1, $2, $3, $4)`, [
                        shift_id,
                        entry.banking_account_id,
                        entry.amount,
                        entry.notes || null
                    ]);
                }
            }
        }
        if (notes) {
            await client.query(`UPDATE shifts SET notes = $1 WHERE id = $2`, [
                notes,
                shift_id
            ]);
        }
        await client.query(`UPDATE shifts SET reconciliation_status = 'reconciled', updated_at = NOW() WHERE id = $1`, [
            shift_id
        ]);
        await client.query('COMMIT');
        // Send DSSR via WhatsApp to directors (async, don't block response)
        try {
            // Get whatsapp_directors from branch level (not vendor level)
            const branchConfigResult = await client.query(`SELECT whatsapp_directors FROM branches WHERE id = $1`, [
                branchId
            ]);
            if (branchConfigResult.rows.length > 0 && branchConfigResult.rows[0].whatsapp_directors) {
                let directorNumbers = [];
                try {
                    const directors = branchConfigResult.rows[0].whatsapp_directors;
                    directorNumbers = typeof directors === 'string' ? JSON.parse(directors) : directors;
                } catch  {
                    directorNumbers = [];
                }
                if (directorNumbers.length > 0) {
                    // Fetch sales data for DSSR
                    const salesResult = await client.query(`SELECT 
               COALESCE(i.item_name, s.fuel_type, 'Unknown') as product,
               SUM(s.quantity) as volume,
               SUM(s.total_amount) as amount,
               SUM(CASE WHEN LOWER(s.payment_method) = 'cash' THEN s.total_amount ELSE 0 END) as cash_amount,
               SUM(CASE WHEN LOWER(s.payment_method) IN ('mpesa', 'm-pesa', 'mobile_money') THEN s.total_amount ELSE 0 END) as mpesa_amount,
               SUM(CASE WHEN LOWER(s.payment_method) = 'credit' THEN s.total_amount ELSE 0 END) as credit_amount
             FROM sales s
             LEFT JOIN items i ON s.item_id = i.id
             WHERE s.shift_id = $1
             GROUP BY COALESCE(i.item_name, s.fuel_type, 'Unknown')`, [
                        shift_id
                    ]);
                    const branchResult = await client.query(`SELECT name FROM branches WHERE id = $1`, [
                        branchId
                    ]);
                    const attendantResult = await client.query(`SELECT s.name FROM staff s
             WHERE s.id = (SELECT staff_id FROM shifts WHERE id = $1)`, [
                        shift_id
                    ]);
                    let totalSales = 0, totalVolume = 0, cashCollected = 0, mpesaCollected = 0, creditSales = 0;
                    const productBreakdown = [];
                    for (const row of salesResult.rows){
                        const volume = parseFloat(row.volume) || 0;
                        const amount = parseFloat(row.amount) || 0;
                        totalVolume += volume;
                        totalSales += amount;
                        cashCollected += parseFloat(row.cash_amount) || 0;
                        mpesaCollected += parseFloat(row.mpesa_amount) || 0;
                        creditSales += parseFloat(row.credit_amount) || 0;
                        productBreakdown.push({
                            product: row.product,
                            volume,
                            amount
                        });
                    }
                    const summary = {
                        branchName: branchResult.rows[0]?.name || 'Unknown Branch',
                        date: new Date().toISOString().split('T')[0],
                        shiftType: shift.shift_type || 'Day',
                        attendantName: attendantResult.rows[0]?.name || 'N/A',
                        totalSales,
                        totalVolume,
                        cashCollected,
                        mpesaCollected,
                        creditSales,
                        variance: cashCollected + mpesaCollected - (totalSales - creditSales),
                        productBreakdown
                    };
                    // Fire and forget - don't wait for WhatsApp response
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$whatsapp$2d$service$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sendDSSRToDirectors"])(summary, directorNumbers).catch((err)=>{
                        console.error('[Reconcile] WhatsApp notification failed:', err);
                    });
                }
            }
        } catch (whatsappError) {
            // Don't fail reconciliation if WhatsApp notification fails
            console.error('[Reconcile] WhatsApp notification error:', whatsappError);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: "Shift reconciled successfully"
        });
    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Error reconciling shift:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Failed to reconcile shift",
            details: error.message
        }, {
            status: 500
        });
    } finally{
        client.release();
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__12b6741d._.js.map