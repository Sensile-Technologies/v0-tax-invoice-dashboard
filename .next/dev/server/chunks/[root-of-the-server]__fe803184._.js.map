{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/reports/dssr/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\ninterface NozzleReading {\n  nozzle_id: string\n  nozzle_name: string\n  dispenser_number: number\n  nozzle_number: number\n  fuel_type: string\n  closing_meter: number\n  opening_meter: number\n  throughput: number\n  rtt: number\n  pump_sales: number\n}\n\ninterface TankMovement {\n  tank_id: string\n  tank_name: string\n  product: string\n  opening_stock: number\n  offloaded_volume: number\n  closing_stock: number\n  tank_sales: number\n  pump_sales: number\n  variance: number\n  variance_percent: number\n}\n\ninterface ProductCashFlow {\n  product: string\n  total_sales_litres: number\n  pump_price: number\n  amount: number\n  actual_cash: number\n  difference: number\n}\n\ninterface DailyCashFlow {\n  opening_cash: number\n  day_shift_cash: number\n  night_shift_cash: number\n  cash_banked: number\n  closing_cash: number\n  physical_count: number\n  difference: number\n}\n\ninterface AttendantCollection {\n  staff_id: string\n  staff_name: string\n  cash: number\n  mpesa: number\n  card: number\n  mobile_money: number\n  credit: number\n  total: number\n}\n\ninterface BankingEntry {\n  id: string\n  account_name: string\n  bank_name: string\n  amount: number\n  notes: string | null\n  created_at: string\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n    const date = searchParams.get('date')\n\n    if (!branchId || !date) {\n      return NextResponse.json(\n        { error: \"branch_id and date are required\" },\n        { status: 400 }\n      )\n    }\n\n    const startOfDay = `${date}T00:00:00`\n    const endOfDay = `${date}T23:59:59`\n\n    const shiftsQuery = `\n      SELECT \n        s.id,\n        s.start_time,\n        s.end_time,\n        s.status,\n        s.opening_cash,\n        s.closing_cash,\n        COALESCE(st.full_name, 'Unknown') as cashier_name,\n        CASE \n          WHEN EXTRACT(HOUR FROM s.start_time) < 14 THEN 'day'\n          ELSE 'night'\n        END as shift_type\n      FROM shifts s\n      LEFT JOIN staff st ON s.staff_id = st.id\n      WHERE s.branch_id = $1\n        AND s.start_time >= $2\n        AND s.start_time <= $3\n      ORDER BY s.start_time ASC\n    `\n    const shiftsResult = await pool.query(shiftsQuery, [branchId, startOfDay, endOfDay])\n    const shiftIds = shiftsResult.rows.map(s => s.id)\n\n    const nozzleReadings: NozzleReading[] = []\n    const productNozzleTotals: Map<string, { throughput: number, rtt: number, pump_sales: number, price_per_litre: number, amount: number }> = new Map()\n\n    const branchItemPricesQuery = `\n      SELECT i.item_name, bi.sale_price\n      FROM branch_items bi\n      JOIN items i ON bi.item_id = i.id\n      WHERE bi.branch_id = $1 AND bi.is_available = true\n    `\n    const branchItemPricesResult = await pool.query(branchItemPricesQuery, [branchId])\n    const productPrices: Map<string, number> = new Map()\n    for (const row of branchItemPricesResult.rows) {\n      productPrices.set(row.item_name, parseFloat(row.sale_price) || 0)\n    }\n\n    if (shiftIds.length > 0) {\n      const nozzleQuery = `\n        SELECT \n          sr.nozzle_id,\n          sr.opening_reading,\n          sr.closing_reading,\n          COALESCE(sr.rtt, 0) as rtt,\n          d.dispenser_number,\n          n.nozzle_number,\n          COALESCE(i.item_name, 'Unknown') as fuel_type\n        FROM shift_readings sr\n        JOIN nozzles n ON sr.nozzle_id = n.id\n        LEFT JOIN dispensers d ON n.dispenser_id = d.id\n        LEFT JOIN items i ON n.item_id = i.id\n        WHERE sr.shift_id = ANY($1) AND sr.reading_type = 'nozzle'\n        ORDER BY d.dispenser_number, n.nozzle_number\n      `\n      const nozzleResult = await pool.query(nozzleQuery, [shiftIds])\n\n      const nozzleAggregates = new Map<string, { \n        nozzle_id: string, \n        nozzle_name: string,\n        dispenser_number: number,\n        nozzle_number: number,\n        fuel_type: string,\n        min_opening: number, \n        max_closing: number, \n        total_rtt: number \n      }>()\n\n      for (const row of nozzleResult.rows) {\n        const key = row.nozzle_id\n        const opening = parseFloat(row.opening_reading) || 0\n        const closing = parseFloat(row.closing_reading) || 0\n        const rtt = parseFloat(row.rtt) || 0\n\n        if (!nozzleAggregates.has(key)) {\n          nozzleAggregates.set(key, {\n            nozzle_id: row.nozzle_id,\n            nozzle_name: `D${row.dispenser_number}N${row.nozzle_number}`,\n            dispenser_number: row.dispenser_number || 0,\n            nozzle_number: row.nozzle_number || 0,\n            fuel_type: row.fuel_type,\n            min_opening: opening,\n            max_closing: closing,\n            total_rtt: rtt\n          })\n        } else {\n          const existing = nozzleAggregates.get(key)!\n          if (opening < existing.min_opening) existing.min_opening = opening\n          if (closing > existing.max_closing) existing.max_closing = closing\n          existing.total_rtt += rtt\n        }\n      }\n\n      for (const [_, data] of nozzleAggregates) {\n        const throughput = data.max_closing - data.min_opening\n        const pump_sales = throughput - data.total_rtt\n\n        nozzleReadings.push({\n          nozzle_id: data.nozzle_id,\n          nozzle_name: data.nozzle_name,\n          dispenser_number: data.dispenser_number,\n          nozzle_number: data.nozzle_number,\n          fuel_type: data.fuel_type,\n          closing_meter: data.max_closing,\n          opening_meter: data.min_opening,\n          throughput: throughput,\n          rtt: data.total_rtt,\n          pump_sales: pump_sales\n        })\n\n        const pricePerLitre = productPrices.get(data.fuel_type) || 0\n        const existing = productNozzleTotals.get(data.fuel_type) || { throughput: 0, rtt: 0, pump_sales: 0, price_per_litre: pricePerLitre, amount: 0 }\n        existing.throughput += throughput\n        existing.rtt += data.total_rtt\n        existing.pump_sales += pump_sales\n        existing.price_per_litre = pricePerLitre\n        existing.amount = existing.pump_sales * pricePerLitre\n        productNozzleTotals.set(data.fuel_type, existing)\n      }\n    }\n\n    const tankMovement: TankMovement[] = []\n\n    const tankQuery = `\n      SELECT \n        t.id as tank_id,\n        t.tank_name,\n        COALESCE(i.item_name, 'Unknown') as fuel_type,\n        t.current_stock\n      FROM tanks t\n      LEFT JOIN items i ON t.item_id = i.id\n      WHERE t.branch_id = $1\n      ORDER BY i.item_name, t.tank_name\n    `\n    const tankResult = await pool.query(tankQuery, [branchId])\n\n    for (const tank of tankResult.rows) {\n      let opening = 0\n      let closing = 0\n      let offloaded = 0\n      let pumpSalesForTank = 0\n\n      if (shiftIds.length > 0) {\n        const tankReadingsQuery = `\n          SELECT \n            sr.opening_reading,\n            sr.closing_reading,\n            COALESCE(sr.stock_received, 0) as stock_received\n          FROM shift_readings sr\n          WHERE sr.shift_id = ANY($1) AND sr.tank_id = $2 AND sr.reading_type = 'tank'\n          ORDER BY sr.created_at ASC\n        `\n        const tankReadings = await pool.query(tankReadingsQuery, [shiftIds, tank.tank_id])\n\n        if (tankReadings.rows.length > 0) {\n          opening = parseFloat(tankReadings.rows[0].opening_reading) || 0\n          closing = parseFloat(tankReadings.rows[tankReadings.rows.length - 1].closing_reading) || 0\n          offloaded = tankReadings.rows.reduce((sum: number, r: any) => sum + (parseFloat(r.stock_received) || 0), 0)\n        }\n\n        const nozzlePumpSalesQuery = `\n          SELECT COALESCE(SUM(\n            COALESCE(sr.closing_reading, 0) - COALESCE(sr.opening_reading, 0) - COALESCE(sr.rtt, 0)\n          ), 0) as pump_sales\n          FROM shift_readings sr\n          JOIN nozzles n ON sr.nozzle_id = n.id\n          WHERE sr.shift_id = ANY($1) \n            AND sr.reading_type = 'nozzle' \n            AND n.tank_id = $2\n        `\n        const pumpSalesResult = await pool.query(nozzlePumpSalesQuery, [shiftIds, tank.tank_id])\n        pumpSalesForTank = parseFloat(pumpSalesResult.rows[0]?.pump_sales) || 0\n      }\n\n      const tank_sales = opening + offloaded - closing\n      const variance = pumpSalesForTank - tank_sales\n      const variance_percent = tank_sales > 0 ? (variance / tank_sales) * 100 : (variance !== 0 ? 100 : 0)\n\n      tankMovement.push({\n        tank_id: tank.tank_id,\n        tank_name: tank.tank_name,\n        product: tank.fuel_type,\n        opening_stock: opening,\n        offloaded_volume: offloaded,\n        closing_stock: closing,\n        tank_sales: tank_sales,\n        pump_sales: pumpSalesForTank,\n        variance: variance,\n        variance_percent: variance_percent\n      })\n    }\n\n    const productCashFlow: ProductCashFlow[] = []\n\n    // Use already-fetched prices from productPrices map (built from branch_items by item_id)\n    for (const [product, nozzleData] of productNozzleTotals) {\n      // Price already fetched via branch_items join - no need to re-query\n      const pump_price = nozzleData.price_per_litre || productPrices.get(product) || 0\n      const amount = nozzleData.pump_sales * pump_price\n\n      productCashFlow.push({\n        product,\n        total_sales_litres: nozzleData.pump_sales,\n        pump_price,\n        amount,\n        actual_cash: 0,\n        difference: 0\n      })\n    }\n\n    const totalSalesAmount = productCashFlow.reduce((sum, p) => sum + p.amount, 0)\n\n    let totalCollections = 0\n    if (shiftIds.length > 0) {\n      const collectionsQuery = `\n        SELECT COALESCE(SUM(ac.amount), 0) as total_collections\n        FROM attendant_collections ac\n        WHERE ac.shift_id = ANY($1)\n      `\n      const collectionsResult = await pool.query(collectionsQuery, [shiftIds])\n      totalCollections = parseFloat(collectionsResult.rows[0]?.total_collections) || 0\n    }\n\n    let openingCash = 0\n    let dayShiftCash = 0\n    let nightShiftCash = 0\n    let cashBanked = 0\n    let closingCash = 0\n\n    for (let i = 0; i < shiftsResult.rows.length; i++) {\n      const shift = shiftsResult.rows[i]\n      \n      if (i === 0) {\n        openingCash = parseFloat(shift.opening_cash) || 0\n      }\n      if (i === shiftsResult.rows.length - 1) {\n        closingCash = parseFloat(shift.closing_cash) || 0\n      }\n      \n      const shiftCollections = await pool.query(\n        `SELECT COALESCE(SUM(amount), 0) as cash_collected\n         FROM attendant_collections WHERE shift_id = $1 AND payment_method = 'cash'`,\n        [shift.id]\n      )\n      const cashCollected = parseFloat(shiftCollections.rows[0]?.cash_collected) || 0\n      \n      if (shift.shift_type === 'day') {\n        dayShiftCash += cashCollected\n      } else {\n        nightShiftCash += cashCollected\n      }\n    }\n\n    if (shiftIds.length > 0) {\n      const bankingQuery = `\n        SELECT COALESCE(SUM(sb.amount), 0) as total_banked\n        FROM shift_banking sb\n        WHERE sb.shift_id = ANY($1)\n      `\n      const bankingResult = await pool.query(bankingQuery, [shiftIds])\n      cashBanked = parseFloat(bankingResult.rows[0]?.total_banked) || 0\n    }\n\n    const dailyCashFlow: DailyCashFlow = {\n      opening_cash: openingCash,\n      day_shift_cash: dayShiftCash,\n      night_shift_cash: nightShiftCash,\n      cash_banked: cashBanked,\n      closing_cash: closingCash,\n      physical_count: closingCash,\n      difference: (openingCash + dayShiftCash + nightShiftCash - cashBanked) - closingCash\n    }\n\n    const attendantCollections: AttendantCollection[] = []\n    if (shiftIds.length > 0) {\n      const collectionsDetailQuery = `\n        SELECT \n          ac.staff_id,\n          COALESCE(st.full_name, 'Unknown') as staff_name,\n          COALESCE(SUM(CASE WHEN ac.payment_method = 'cash' THEN ac.amount ELSE 0 END), 0) as cash,\n          COALESCE(SUM(CASE WHEN ac.payment_method = 'mpesa' THEN ac.amount ELSE 0 END), 0) as mpesa,\n          COALESCE(SUM(CASE WHEN ac.payment_method = 'card' THEN ac.amount ELSE 0 END), 0) as card,\n          COALESCE(SUM(CASE WHEN ac.payment_method = 'mobile_money' THEN ac.amount ELSE 0 END), 0) as mobile_money,\n          COALESCE(SUM(CASE WHEN ac.payment_method = 'credit' THEN ac.amount ELSE 0 END), 0) as credit,\n          COALESCE(SUM(ac.amount), 0) as total\n        FROM attendant_collections ac\n        LEFT JOIN staff st ON ac.staff_id = st.id\n        WHERE ac.shift_id = ANY($1)\n        GROUP BY ac.staff_id, st.full_name\n        ORDER BY st.full_name\n      `\n      const collectionsDetailResult = await pool.query(collectionsDetailQuery, [shiftIds])\n      for (const row of collectionsDetailResult.rows) {\n        attendantCollections.push({\n          staff_id: row.staff_id,\n          staff_name: row.staff_name,\n          cash: parseFloat(row.cash) || 0,\n          mpesa: parseFloat(row.mpesa) || 0,\n          card: parseFloat(row.card) || 0,\n          mobile_money: parseFloat(row.mobile_money) || 0,\n          credit: parseFloat(row.credit) || 0,\n          total: parseFloat(row.total) || 0\n        })\n      }\n    }\n\n    const bankingEntries: BankingEntry[] = []\n    if (shiftIds.length > 0) {\n      const bankingDetailQuery = `\n        SELECT \n          sb.id,\n          ba.account_name,\n          ba.bank_name,\n          sb.amount,\n          sb.notes,\n          sb.created_at\n        FROM shift_banking sb\n        LEFT JOIN banking_accounts ba ON sb.banking_account_id = ba.id\n        WHERE sb.shift_id = ANY($1)\n        ORDER BY sb.created_at\n      `\n      const bankingDetailResult = await pool.query(bankingDetailQuery, [shiftIds])\n      for (const row of bankingDetailResult.rows) {\n        bankingEntries.push({\n          id: row.id,\n          account_name: row.account_name || 'Unknown Account',\n          bank_name: row.bank_name || '',\n          amount: parseFloat(row.amount) || 0,\n          notes: row.notes,\n          created_at: row.created_at\n        })\n      }\n    }\n\n    const branchQuery = `SELECT name FROM branches WHERE id = $1`\n    const branchResult = await pool.query(branchQuery, [branchId])\n    const branchName = branchResult.rows[0]?.name || 'Unknown Branch'\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        date,\n        branch_name: branchName,\n        shifts: shiftsResult.rows.map(s => ({\n          id: s.id,\n          start_time: s.start_time,\n          end_time: s.end_time,\n          cashier_name: s.cashier_name,\n          shift_type: s.shift_type\n        })),\n        nozzle_readings: nozzleReadings.sort((a, b) => {\n          if (a.dispenser_number !== b.dispenser_number) return a.dispenser_number - b.dispenser_number\n          return a.nozzle_number - b.nozzle_number\n        }),\n        product_nozzle_totals: Array.from(productNozzleTotals.entries()).map(([product, data]) => ({\n          product,\n          ...data\n        })),\n        tank_movement: tankMovement,\n        product_cash_flow: productCashFlow,\n        daily_cash_flow: dailyCashFlow,\n        attendant_collections: attendantCollections,\n        banking_entries: bankingEntries,\n        totals: {\n          total_sales_amount: totalSalesAmount,\n          total_collections: totalCollections,\n          sales_vs_collections_diff: totalSalesAmount - totalCollections\n        }\n      }\n    })\n\n  } catch (error) {\n    console.error(\"DSSR API error:\", error)\n    return NextResponse.json(\n      { error: \"Failed to generate DSSR report\" },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}