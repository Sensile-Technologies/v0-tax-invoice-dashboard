{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/reports/dssr/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\ninterface NozzleReading {\n  nozzle_id: string\n  nozzle_name: string\n  dispenser_number: number\n  nozzle_number: number\n  fuel_type: string\n  closing_meter: number\n  opening_meter: number\n  throughput: number\n  rtt: number\n  pump_sales: number\n}\n\ninterface ProductMovement {\n  product: string\n  opening_stock: number\n  offloaded_volume: number\n  closing_stock: number\n  tank_sales: number\n  pump_sales: number\n  variance: number\n  variance_percent: number\n}\n\ninterface ProductCashFlow {\n  product: string\n  total_sales_litres: number\n  pump_price: number\n  amount: number\n  actual_cash: number\n  difference: number\n}\n\ninterface DailyCashFlow {\n  opening_cash: number\n  day_shift_cash: number\n  night_shift_cash: number\n  cash_banked: number\n  closing_cash: number\n  physical_count: number\n  difference: number\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n    const date = searchParams.get('date')\n\n    if (!branchId || !date) {\n      return NextResponse.json(\n        { error: \"branch_id and date are required\" },\n        { status: 400 }\n      )\n    }\n\n    const startOfDay = `${date}T00:00:00`\n    const endOfDay = `${date}T23:59:59`\n\n    const shiftsQuery = `\n      SELECT \n        s.id,\n        s.start_time,\n        s.end_time,\n        s.status,\n        s.opening_cash,\n        s.closing_cash,\n        COALESCE(st.full_name, 'Unknown') as cashier_name,\n        CASE \n          WHEN EXTRACT(HOUR FROM s.start_time) < 14 THEN 'day'\n          ELSE 'night'\n        END as shift_type\n      FROM shifts s\n      LEFT JOIN staff st ON s.staff_id = st.id\n      WHERE s.branch_id = $1\n        AND s.start_time >= $2\n        AND s.start_time <= $3\n      ORDER BY s.start_time ASC\n    `\n    const shiftsResult = await pool.query(shiftsQuery, [branchId, startOfDay, endOfDay])\n    const shiftIds = shiftsResult.rows.map(s => s.id)\n\n    const nozzleReadings: NozzleReading[] = []\n    const productNozzleTotals: Map<string, { throughput: number, rtt: number, pump_sales: number }> = new Map()\n\n    if (shiftIds.length > 0) {\n      const nozzleQuery = `\n        SELECT \n          sr.nozzle_id,\n          sr.opening_reading,\n          sr.closing_reading,\n          COALESCE(sr.rtt, 0) as rtt,\n          d.dispenser_number,\n          n.nozzle_number,\n          COALESCE(i.item_name, 'Unknown') as fuel_type\n        FROM shift_readings sr\n        JOIN nozzles n ON sr.nozzle_id = n.id\n        LEFT JOIN dispensers d ON n.dispenser_id = d.id\n        LEFT JOIN items i ON n.item_id = i.id\n        WHERE sr.shift_id = ANY($1) AND sr.reading_type = 'nozzle'\n        ORDER BY d.dispenser_number, n.nozzle_number\n      `\n      const nozzleResult = await pool.query(nozzleQuery, [shiftIds])\n\n      const nozzleAggregates = new Map<string, { \n        nozzle_id: string, \n        nozzle_name: string,\n        dispenser_number: number,\n        nozzle_number: number,\n        fuel_type: string,\n        min_opening: number, \n        max_closing: number, \n        total_rtt: number \n      }>()\n\n      for (const row of nozzleResult.rows) {\n        const key = row.nozzle_id\n        const opening = parseFloat(row.opening_reading) || 0\n        const closing = parseFloat(row.closing_reading) || 0\n        const rtt = parseFloat(row.rtt) || 0\n\n        if (!nozzleAggregates.has(key)) {\n          nozzleAggregates.set(key, {\n            nozzle_id: row.nozzle_id,\n            nozzle_name: `D${row.dispenser_number}N${row.nozzle_number}`,\n            dispenser_number: row.dispenser_number || 0,\n            nozzle_number: row.nozzle_number || 0,\n            fuel_type: row.fuel_type,\n            min_opening: opening,\n            max_closing: closing,\n            total_rtt: rtt\n          })\n        } else {\n          const existing = nozzleAggregates.get(key)!\n          if (opening < existing.min_opening) existing.min_opening = opening\n          if (closing > existing.max_closing) existing.max_closing = closing\n          existing.total_rtt += rtt\n        }\n      }\n\n      for (const [_, data] of nozzleAggregates) {\n        const throughput = data.max_closing - data.min_opening\n        const pump_sales = throughput - data.total_rtt\n\n        nozzleReadings.push({\n          nozzle_id: data.nozzle_id,\n          nozzle_name: data.nozzle_name,\n          dispenser_number: data.dispenser_number,\n          nozzle_number: data.nozzle_number,\n          fuel_type: data.fuel_type,\n          closing_meter: data.max_closing,\n          opening_meter: data.min_opening,\n          throughput: throughput,\n          rtt: data.total_rtt,\n          pump_sales: pump_sales\n        })\n\n        const existing = productNozzleTotals.get(data.fuel_type) || { throughput: 0, rtt: 0, pump_sales: 0 }\n        existing.throughput += throughput\n        existing.rtt += data.total_rtt\n        existing.pump_sales += pump_sales\n        productNozzleTotals.set(data.fuel_type, existing)\n      }\n    }\n\n    const productMovement: ProductMovement[] = []\n\n    const tankQuery = `\n      SELECT \n        t.id as tank_id,\n        t.tank_name,\n        COALESCE(i.item_name, 'Unknown') as fuel_type,\n        t.current_stock\n      FROM tanks t\n      LEFT JOIN items i ON t.item_id = i.id\n      WHERE t.branch_id = $1\n      ORDER BY i.item_name, t.tank_name\n    `\n    const tankResult = await pool.query(tankQuery, [branchId])\n\n    const productTankData: Map<string, { \n      opening_stock: number, \n      offloaded: number, \n      closing_stock: number \n    }> = new Map()\n\n    for (const tank of tankResult.rows) {\n      if (shiftIds.length > 0) {\n        const tankReadingsQuery = `\n          SELECT \n            sr.opening_reading,\n            sr.closing_reading,\n            COALESCE(sr.stock_received, 0) as stock_received\n          FROM shift_readings sr\n          WHERE sr.shift_id = ANY($1) AND sr.tank_id = $2 AND sr.reading_type = 'tank'\n          ORDER BY sr.created_at ASC\n        `\n        const tankReadings = await pool.query(tankReadingsQuery, [shiftIds, tank.tank_id])\n\n        let opening = 0\n        let closing = parseFloat(tank.current_stock) || 0\n        let offloaded = 0\n\n        if (tankReadings.rows.length > 0) {\n          opening = parseFloat(tankReadings.rows[0].opening_reading) || 0\n          closing = parseFloat(tankReadings.rows[tankReadings.rows.length - 1].closing_reading) || closing\n          offloaded = tankReadings.rows.reduce((sum: number, r: any) => sum + (parseFloat(r.stock_received) || 0), 0)\n        }\n\n        const existing = productTankData.get(tank.fuel_type) || { opening_stock: 0, offloaded: 0, closing_stock: 0 }\n        existing.opening_stock += opening\n        existing.offloaded += offloaded\n        existing.closing_stock += closing\n        productTankData.set(tank.fuel_type, existing)\n      }\n    }\n\n    for (const [product, tankData] of productTankData) {\n      const nozzleData = productNozzleTotals.get(product) || { throughput: 0, rtt: 0, pump_sales: 0 }\n      const tank_sales = tankData.opening_stock + tankData.offloaded - tankData.closing_stock\n      const variance = nozzleData.pump_sales - tank_sales\n      const variance_percent = tank_sales > 0 ? (variance / tank_sales) * 100 : (variance !== 0 ? 100 : 0)\n\n      productMovement.push({\n        product,\n        opening_stock: tankData.opening_stock,\n        offloaded_volume: tankData.offloaded,\n        closing_stock: tankData.closing_stock,\n        tank_sales: tank_sales,\n        pump_sales: nozzleData.pump_sales,\n        variance: variance,\n        variance_percent: variance_percent\n      })\n    }\n\n    const productCashFlow: ProductCashFlow[] = []\n\n    for (const [product, nozzleData] of productNozzleTotals) {\n      const priceQuery = `\n        SELECT COALESCE(bi.sale_price, 0) as sale_price\n        FROM items i\n        LEFT JOIN branch_items bi ON bi.item_id = i.id AND bi.branch_id = $1\n        WHERE i.item_name = $2\n        LIMIT 1\n      `\n      const priceResult = await pool.query(priceQuery, [branchId, product])\n      const pump_price = parseFloat(priceResult.rows[0]?.sale_price) || 0\n      const amount = nozzleData.pump_sales * pump_price\n\n      productCashFlow.push({\n        product,\n        total_sales_litres: nozzleData.pump_sales,\n        pump_price,\n        amount,\n        actual_cash: 0,\n        difference: 0\n      })\n    }\n\n    const totalSalesAmount = productCashFlow.reduce((sum, p) => sum + p.amount, 0)\n\n    let totalCollections = 0\n    if (shiftIds.length > 0) {\n      const collectionsQuery = `\n        SELECT COALESCE(SUM(ac.amount), 0) as total_collections\n        FROM attendant_collections ac\n        WHERE ac.shift_id = ANY($1)\n      `\n      const collectionsResult = await pool.query(collectionsQuery, [shiftIds])\n      totalCollections = parseFloat(collectionsResult.rows[0]?.total_collections) || 0\n    }\n\n    let openingCash = 0\n    let dayShiftCash = 0\n    let nightShiftCash = 0\n    let cashBanked = 0\n    let closingCash = 0\n\n    for (let i = 0; i < shiftsResult.rows.length; i++) {\n      const shift = shiftsResult.rows[i]\n      \n      if (i === 0) {\n        openingCash = parseFloat(shift.opening_cash) || 0\n      }\n      if (i === shiftsResult.rows.length - 1) {\n        closingCash = parseFloat(shift.closing_cash) || 0\n      }\n      \n      const shiftCollections = await pool.query(\n        `SELECT COALESCE(SUM(amount), 0) as cash_collected\n         FROM attendant_collections WHERE shift_id = $1 AND payment_method = 'cash'`,\n        [shift.id]\n      )\n      const cashCollected = parseFloat(shiftCollections.rows[0]?.cash_collected) || 0\n      \n      if (shift.shift_type === 'day') {\n        dayShiftCash += cashCollected\n      } else {\n        nightShiftCash += cashCollected\n      }\n    }\n\n    if (shiftIds.length > 0) {\n      const bankingQuery = `\n        SELECT COALESCE(SUM(sb.amount), 0) as total_banked\n        FROM shift_banking sb\n        WHERE sb.shift_id = ANY($1)\n      `\n      const bankingResult = await pool.query(bankingQuery, [shiftIds])\n      cashBanked = parseFloat(bankingResult.rows[0]?.total_banked) || 0\n    }\n\n    const dailyCashFlow: DailyCashFlow = {\n      opening_cash: openingCash,\n      day_shift_cash: dayShiftCash,\n      night_shift_cash: nightShiftCash,\n      cash_banked: cashBanked,\n      closing_cash: closingCash,\n      physical_count: closingCash,\n      difference: (openingCash + dayShiftCash + nightShiftCash - cashBanked) - closingCash\n    }\n\n    const branchQuery = `SELECT name FROM branches WHERE id = $1`\n    const branchResult = await pool.query(branchQuery, [branchId])\n    const branchName = branchResult.rows[0]?.name || 'Unknown Branch'\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        date,\n        branch_name: branchName,\n        shifts: shiftsResult.rows.map(s => ({\n          id: s.id,\n          start_time: s.start_time,\n          end_time: s.end_time,\n          cashier_name: s.cashier_name,\n          shift_type: s.shift_type\n        })),\n        nozzle_readings: nozzleReadings.sort((a, b) => {\n          if (a.dispenser_number !== b.dispenser_number) return a.dispenser_number - b.dispenser_number\n          return a.nozzle_number - b.nozzle_number\n        }),\n        product_nozzle_totals: Array.from(productNozzleTotals.entries()).map(([product, data]) => ({\n          product,\n          ...data\n        })),\n        product_movement: productMovement,\n        product_cash_flow: productCashFlow,\n        daily_cash_flow: dailyCashFlow,\n        totals: {\n          total_sales_amount: totalSalesAmount,\n          total_collections: totalCollections,\n          sales_vs_collections_diff: totalSalesAmount - totalCollections\n        }\n      }\n    })\n\n  } catch (error) {\n    console.error(\"DSSR API error:\", error)\n    return NextResponse.json(\n      { error: \"Failed to generate DSSR report\" },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}