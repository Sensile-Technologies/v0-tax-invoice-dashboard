{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/shifts/end-all/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const vendorId = searchParams.get('vendor_id')\n    const userId = searchParams.get('user_id')\n\n    let branchFilter = ''\n    const params: any[] = []\n\n    if (vendorId) {\n      params.push(vendorId)\n      branchFilter = `AND b.vendor_id = $${params.length}`\n    } else if (userId) {\n      params.push(userId)\n      branchFilter = `AND (b.vendor_id IN (SELECT vendor_id FROM staff WHERE id = $${params.length}) OR EXISTS (SELECT 1 FROM staff WHERE id = $${params.length} AND role IN ('admin', 'superadmin')))`\n    }\n\n    const result = await pool.query(`\n      SELECT \n        s.id,\n        s.branch_id,\n        s.start_time,\n        s.opening_cash,\n        s.status,\n        b.name as branch_name,\n        b.location as branch_location,\n        COALESCE(st.name, 'Unknown') as cashier_name,\n        (SELECT COALESCE(SUM(total), 0) FROM sales WHERE branch_id = s.branch_id AND shift_id = s.id) as total_sales\n      FROM shifts s\n      JOIN branches b ON s.branch_id = b.id\n      LEFT JOIN staff st ON s.cashier_id = st.id\n      WHERE s.status = 'active'\n      ${branchFilter}\n      ORDER BY b.name\n    `, params)\n\n    const shifts = result.rows\n\n    const shiftsWithDetails = await Promise.all(shifts.map(async (shift) => {\n      const nozzlesResult = await pool.query(`\n        SELECT n.id, n.nozzle_number, n.fuel_type, n.initial_meter_reading,\n               COALESCE(\n                 (SELECT sr.closing_reading FROM shift_readings sr \n                  WHERE sr.nozzle_id = n.id AND sr.reading_type = 'nozzle'\n                  ORDER BY sr.created_at DESC LIMIT 1),\n                 n.initial_meter_reading\n               ) as current_reading,\n               d.dispenser_number\n        FROM nozzles n\n        LEFT JOIN dispensers d ON n.dispenser_id = d.id\n        WHERE n.branch_id = $1 AND n.status = 'active'\n        ORDER BY d.dispenser_number, n.nozzle_number\n      `, [shift.branch_id])\n\n      const tanksResult = await pool.query(`\n        SELECT id, tank_name, fuel_type, capacity, current_stock\n        FROM tanks\n        WHERE branch_id = $1 AND status = 'active'\n        ORDER BY tank_name\n      `, [shift.branch_id])\n\n      return {\n        ...shift,\n        nozzles: nozzlesResult.rows,\n        tanks: tanksResult.rows\n      }\n    }))\n\n    return NextResponse.json({\n      success: true,\n      data: shiftsWithDetails\n    })\n\n  } catch (error: any) {\n    console.error(\"Error fetching active shifts:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch active shifts\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  const client = await pool.connect()\n  try {\n    const body = await request.json()\n    const { shifts: shiftsToEnd } = body\n\n    if (!shiftsToEnd || !Array.isArray(shiftsToEnd) || shiftsToEnd.length === 0) {\n      return NextResponse.json(\n        { error: \"No shifts provided to end\" },\n        { status: 400 }\n      )\n    }\n\n    await client.query('BEGIN')\n\n    const results: any[] = []\n    const errors: any[] = []\n\n    for (const shiftData of shiftsToEnd) {\n      const { id, closing_cash, nozzle_readings, tank_stocks } = shiftData\n\n      try {\n        const shiftCheck = await client.query(\n          `SELECT * FROM shifts WHERE id = $1 AND status = 'active'`,\n          [id]\n        )\n\n        if (shiftCheck.rows.length === 0) {\n          errors.push({ id, error: \"Shift not found or already closed\" })\n          continue\n        }\n\n        const currentShift = shiftCheck.rows[0]\n        const branchId = currentShift.branch_id\n        const endTimeValue = new Date().toISOString()\n\n        const nozzlesResult = await client.query(\n          `SELECT id, initial_meter_reading FROM nozzles WHERE branch_id = $1`,\n          [branchId]\n        )\n        const nozzleBaseReadings: Record<string, number> = {}\n        for (const n of nozzlesResult.rows) {\n          nozzleBaseReadings[n.id] = parseFloat(n.initial_meter_reading) || 0\n        }\n\n        const prevNozzleReadings = await client.query(\n          `SELECT nozzle_id, closing_reading FROM shift_readings \n           WHERE branch_id = $1 AND reading_type = 'nozzle' AND nozzle_id IS NOT NULL\n           ORDER BY created_at DESC`,\n          [branchId]\n        )\n        for (const r of prevNozzleReadings.rows) {\n          if (!nozzleBaseReadings[r.nozzle_id] || parseFloat(r.closing_reading) > nozzleBaseReadings[r.nozzle_id]) {\n            nozzleBaseReadings[r.nozzle_id] = parseFloat(r.closing_reading)\n          }\n        }\n\n        const tanksResult = await client.query(\n          `SELECT id, current_stock FROM tanks WHERE branch_id = $1`,\n          [branchId]\n        )\n        const tankBaseStocks: Record<string, number> = {}\n        for (const t of tanksResult.rows) {\n          tankBaseStocks[t.id] = parseFloat(t.current_stock) || 0\n        }\n\n        let hasValidationError = false\n        \n        if (nozzle_readings && nozzle_readings.length > 0) {\n          for (const reading of nozzle_readings) {\n            if (reading.nozzle_id && !isNaN(reading.closing_reading)) {\n              if (!nozzleBaseReadings.hasOwnProperty(reading.nozzle_id)) {\n                errors.push({ \n                  id, \n                  error: `Nozzle ${reading.nozzle_id} does not belong to this branch` \n                })\n                hasValidationError = true\n                break\n              }\n              const openingReading = nozzleBaseReadings[reading.nozzle_id] || 0\n              if (reading.closing_reading < openingReading) {\n                errors.push({ \n                  id, \n                  error: `Nozzle closing reading (${reading.closing_reading}) cannot be less than opening reading (${openingReading})` \n                })\n                hasValidationError = true\n                break\n              }\n            }\n          }\n        }\n\n        if (tank_stocks && tank_stocks.length > 0) {\n          for (const stock of tank_stocks) {\n            if (stock.tank_id && !isNaN(stock.closing_reading)) {\n              if (!tankBaseStocks.hasOwnProperty(stock.tank_id)) {\n                errors.push({ \n                  id, \n                  error: `Tank ${stock.tank_id} does not belong to this branch` \n                })\n                hasValidationError = true\n                break\n              }\n            }\n          }\n        }\n\n        if (hasValidationError) {\n          continue\n        }\n\n        const salesResult = await client.query(\n          `SELECT COALESCE(SUM(total), 0) as total_sales FROM sales WHERE branch_id = $1 AND shift_id = $2`,\n          [branchId, id]\n        )\n        const totalSales = parseFloat(salesResult.rows[0].total_sales) || 0\n\n        const result = await client.query(\n          `UPDATE shifts \n           SET end_time = $1, closing_cash = $2, total_sales = $3, status = 'completed', updated_at = NOW()\n           WHERE id = $4\n           RETURNING *`,\n          [endTimeValue, closing_cash || 0, totalSales, id]\n        )\n\n        const shift = result.rows[0]\n\n        await client.query(\n          `DELETE FROM shift_readings WHERE shift_id = $1`,\n          [id]\n        )\n\n        if (nozzle_readings && nozzle_readings.length > 0) {\n          for (const reading of nozzle_readings) {\n            if (reading.nozzle_id && !isNaN(reading.closing_reading)) {\n              const openingReading = nozzleBaseReadings[reading.nozzle_id] || 0\n              await client.query(\n                `INSERT INTO shift_readings (shift_id, branch_id, reading_type, nozzle_id, opening_reading, closing_reading)\n                 VALUES ($1, $2, 'nozzle', $3, $4, $5)`,\n                [id, branchId, reading.nozzle_id, openingReading, reading.closing_reading]\n              )\n            }\n          }\n        }\n\n        if (tank_stocks && tank_stocks.length > 0) {\n          for (const stock of tank_stocks) {\n            if (stock.tank_id && !isNaN(stock.closing_reading)) {\n              const openingStock = tankBaseStocks[stock.tank_id] || 0\n              const stockReceived = stock.stock_received || 0\n\n              await client.query(\n                `INSERT INTO shift_readings (shift_id, branch_id, reading_type, tank_id, opening_reading, closing_reading, stock_received)\n                 VALUES ($1, $2, 'tank', $3, $4, $5, $6)`,\n                [id, branchId, stock.tank_id, openingStock, stock.closing_reading, stockReceived]\n              )\n\n              await client.query(\n                `UPDATE tanks SET current_stock = $1, updated_at = NOW() WHERE id = $2`,\n                [stock.closing_reading, stock.tank_id]\n              )\n            }\n          }\n        }\n\n        const newShiftResult = await client.query(\n          `INSERT INTO shifts (branch_id, start_time, status, opening_cash, notes, created_at)\n           VALUES ($1, $2, 'active', $3, NULL, NOW())\n           RETURNING *`,\n          [branchId, endTimeValue, closing_cash || 0]\n        )\n\n        results.push({\n          closedShift: shift,\n          newShift: newShiftResult.rows[0]\n        })\n\n      } catch (shiftError: any) {\n        errors.push({ id, error: shiftError.message })\n      }\n    }\n\n    if (errors.length > 0 && results.length === 0) {\n      await client.query('ROLLBACK')\n      return NextResponse.json(\n        { error: \"Failed to end shifts\", errors },\n        { status: 400 }\n      )\n    }\n\n    await client.query('COMMIT')\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        closed: results,\n        errors: errors.length > 0 ? errors : undefined\n      }\n    })\n\n  } catch (error: any) {\n    await client.query('ROLLBACK')\n    console.error(\"Error ending shifts:\", error)\n    return NextResponse.json(\n      { error: \"Failed to end shifts\", details: error.message },\n      { status: 500 }\n    )\n  } finally {\n    client.release()\n  }\n}\n"],"names":[],"mappings":"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"}}]
}