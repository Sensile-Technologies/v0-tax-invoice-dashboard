{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/shifts/baselines/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n\n    if (!branchId) {\n      return NextResponse.json(\n        { error: \"branch_id is required\" },\n        { status: 400 }\n      )\n    }\n\n    // Only include nozzles that have a tank assigned\n    const nozzlesResult = await pool.query(\n      `SELECT id, initial_meter_reading FROM nozzles WHERE branch_id = $1 AND tank_id IS NOT NULL`,\n      [branchId]\n    )\n    const nozzleBaselines: Record<string, number> = {}\n    for (const n of nozzlesResult.rows) {\n      nozzleBaselines[n.id] = parseFloat(n.initial_meter_reading) || 0\n    }\n\n    // Get closing readings only from completed shifts (not from sales or other sources)\n    const prevNozzleReadings = await pool.query(\n      `SELECT DISTINCT ON (sr.nozzle_id) sr.nozzle_id, sr.closing_reading \n       FROM shift_readings sr\n       JOIN shifts s ON sr.shift_id = s.id\n       WHERE sr.branch_id = $1 \n         AND sr.reading_type = 'nozzle' \n         AND sr.nozzle_id IS NOT NULL\n         AND s.status = 'completed'\n       ORDER BY sr.nozzle_id, s.end_time DESC NULLS LAST`,\n      [branchId]\n    )\n    for (const r of prevNozzleReadings.rows) {\n      // Only update baselines for nozzles that have a tank assigned (already in nozzleBaselines)\n      if (nozzleBaselines.hasOwnProperty(r.nozzle_id)) {\n        const closingVal = parseFloat(r.closing_reading) || 0\n        if (closingVal > (nozzleBaselines[r.nozzle_id] || 0)) {\n          nozzleBaselines[r.nozzle_id] = closingVal\n        }\n      }\n    }\n\n    const tanksResult = await pool.query(\n      `SELECT id, current_stock FROM tanks WHERE branch_id = $1`,\n      [branchId]\n    )\n    const tankBaselines: Record<string, number> = {}\n    for (const t of tanksResult.rows) {\n      tankBaselines[t.id] = parseFloat(t.current_stock) || 0\n    }\n\n    return NextResponse.json({\n      success: true,\n      nozzleBaselines,\n      tankBaselines\n    })\n\n  } catch (error: any) {\n    console.error(\"Error fetching baselines:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch baselines\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAC5C;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;QAElC,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,iDAAiD;QACjD,MAAM,gBAAgB,MAAM,KAAK,KAAK,CACpC,CAAC,0FAA0F,CAAC,EAC5F;YAAC;SAAS;QAEZ,MAAM,kBAA0C,CAAC;QACjD,KAAK,MAAM,KAAK,cAAc,IAAI,CAAE;YAClC,eAAe,CAAC,EAAE,EAAE,CAAC,GAAG,WAAW,EAAE,qBAAqB,KAAK;QACjE;QAEA,oFAAoF;QACpF,MAAM,qBAAqB,MAAM,KAAK,KAAK,CACzC,CAAC;;;;;;;wDAOiD,CAAC,EACnD;YAAC;SAAS;QAEZ,KAAK,MAAM,KAAK,mBAAmB,IAAI,CAAE;YACvC,2FAA2F;YAC3F,IAAI,gBAAgB,cAAc,CAAC,EAAE,SAAS,GAAG;gBAC/C,MAAM,aAAa,WAAW,EAAE,eAAe,KAAK;gBACpD,IAAI,aAAa,CAAC,eAAe,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,GAAG;oBACpD,eAAe,CAAC,EAAE,SAAS,CAAC,GAAG;gBACjC;YACF;QACF;QAEA,MAAM,cAAc,MAAM,KAAK,KAAK,CAClC,CAAC,wDAAwD,CAAC,EAC1D;YAAC;SAAS;QAEZ,MAAM,gBAAwC,CAAC;QAC/C,KAAK,MAAM,KAAK,YAAY,IAAI,CAAE;YAChC,aAAa,CAAC,EAAE,EAAE,CAAC,GAAG,WAAW,EAAE,aAAa,KAAK;QACvD;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA;QACF;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAA6B,SAAS,MAAM,OAAO;QAAC,GAC7D;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}