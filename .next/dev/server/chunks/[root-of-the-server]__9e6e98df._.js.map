{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/shifts/baselines/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n\n    if (!branchId) {\n      return NextResponse.json(\n        { error: \"branch_id is required\" },\n        { status: 400 }\n      )\n    }\n\n    // Only include nozzles that have a tank assigned\n    const nozzlesResult = await pool.query(\n      `SELECT id, initial_meter_reading FROM nozzles WHERE branch_id = $1 AND tank_id IS NOT NULL`,\n      [branchId]\n    )\n    const nozzleBaselines: Record<string, number> = {}\n    for (const n of nozzlesResult.rows) {\n      nozzleBaselines[n.id] = parseFloat(n.initial_meter_reading) || 0\n    }\n\n    // Get closing readings only from completed shifts (not from sales or other sources)\n    const prevNozzleReadings = await pool.query(\n      `SELECT DISTINCT ON (sr.nozzle_id) sr.nozzle_id, sr.closing_reading \n       FROM shift_readings sr\n       JOIN shifts s ON sr.shift_id = s.id\n       WHERE sr.branch_id = $1 \n         AND sr.reading_type = 'nozzle' \n         AND sr.nozzle_id IS NOT NULL\n         AND s.status = 'completed'\n       ORDER BY sr.nozzle_id, s.end_time DESC NULLS LAST`,\n      [branchId]\n    )\n    for (const r of prevNozzleReadings.rows) {\n      // Only update baselines for nozzles that have a tank assigned (already in nozzleBaselines)\n      if (nozzleBaselines.hasOwnProperty(r.nozzle_id)) {\n        const closingVal = parseFloat(r.closing_reading) || 0\n        if (closingVal > (nozzleBaselines[r.nozzle_id] || 0)) {\n          nozzleBaselines[r.nozzle_id] = closingVal\n        }\n      }\n    }\n\n    // Get tanks for this branch\n    const tanksResult = await pool.query(\n      `SELECT id FROM tanks WHERE branch_id = $1`,\n      [branchId]\n    )\n    \n    // CRITICAL: Tank opening reading = previous shift's CLOSING reading ONLY\n    // This ensures tank continuity: Shift A closing = Shift B opening\n    // NO fallback to tanks.current_stock - it must come from shift_readings\n    const tankBaselines: Record<string, number> = {}\n    \n    // Get the most recent completed shift's closing readings for each tank\n    const prevTankReadings = await pool.query(\n      `SELECT DISTINCT ON (sr.tank_id) sr.tank_id, sr.closing_reading\n       FROM shift_readings sr\n       JOIN shifts s ON sr.shift_id = s.id\n       WHERE sr.branch_id = $1 \n         AND sr.reading_type = 'tank' \n         AND sr.tank_id IS NOT NULL\n         AND sr.closing_reading IS NOT NULL\n         AND s.status = 'completed'\n       ORDER BY sr.tank_id, s.end_time DESC NULLS LAST`,\n      [branchId]\n    )\n    \n    // Build map of previous closing readings\n    const prevClosings: Record<string, number> = {}\n    for (const r of prevTankReadings.rows) {\n      prevClosings[r.tank_id] = parseFloat(r.closing_reading) || 0\n    }\n    \n    // For each tank, use previous closing reading; default to 0 if no prior readings exist\n    for (const t of tanksResult.rows) {\n      tankBaselines[t.id] = prevClosings[t.id] ?? 0\n    }\n\n    return NextResponse.json({\n      success: true,\n      nozzleBaselines,\n      tankBaselines\n    })\n\n  } catch (error: any) {\n    console.error(\"Error fetching baselines:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch baselines\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAC5C;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;QAElC,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,iDAAiD;QACjD,MAAM,gBAAgB,MAAM,KAAK,KAAK,CACpC,CAAC,0FAA0F,CAAC,EAC5F;YAAC;SAAS;QAEZ,MAAM,kBAA0C,CAAC;QACjD,KAAK,MAAM,KAAK,cAAc,IAAI,CAAE;YAClC,eAAe,CAAC,EAAE,EAAE,CAAC,GAAG,WAAW,EAAE,qBAAqB,KAAK;QACjE;QAEA,oFAAoF;QACpF,MAAM,qBAAqB,MAAM,KAAK,KAAK,CACzC,CAAC;;;;;;;wDAOiD,CAAC,EACnD;YAAC;SAAS;QAEZ,KAAK,MAAM,KAAK,mBAAmB,IAAI,CAAE;YACvC,2FAA2F;YAC3F,IAAI,gBAAgB,cAAc,CAAC,EAAE,SAAS,GAAG;gBAC/C,MAAM,aAAa,WAAW,EAAE,eAAe,KAAK;gBACpD,IAAI,aAAa,CAAC,eAAe,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,GAAG;oBACpD,eAAe,CAAC,EAAE,SAAS,CAAC,GAAG;gBACjC;YACF;QACF;QAEA,4BAA4B;QAC5B,MAAM,cAAc,MAAM,KAAK,KAAK,CAClC,CAAC,yCAAyC,CAAC,EAC3C;YAAC;SAAS;QAGZ,yEAAyE;QACzE,kEAAkE;QAClE,wEAAwE;QACxE,MAAM,gBAAwC,CAAC;QAE/C,uEAAuE;QACvE,MAAM,mBAAmB,MAAM,KAAK,KAAK,CACvC,CAAC;;;;;;;;sDAQ+C,CAAC,EACjD;YAAC;SAAS;QAGZ,yCAAyC;QACzC,MAAM,eAAuC,CAAC;QAC9C,KAAK,MAAM,KAAK,iBAAiB,IAAI,CAAE;YACrC,YAAY,CAAC,EAAE,OAAO,CAAC,GAAG,WAAW,EAAE,eAAe,KAAK;QAC7D;QAEA,uFAAuF;QACvF,KAAK,MAAM,KAAK,YAAY,IAAI,CAAE;YAChC,aAAa,CAAC,EAAE,EAAE,CAAC,GAAG,YAAY,CAAC,EAAE,EAAE,CAAC,IAAI;QAC9C;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA;QACF;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAA6B,SAAS,MAAM,OAAO;QAAC,GAC7D;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}