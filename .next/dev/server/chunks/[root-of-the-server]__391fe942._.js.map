{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/shifts/incoming-attendants/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n\n    if (!branchId) {\n      return NextResponse.json(\n        { error: \"branch_id is required\" },\n        { status: 400 }\n      )\n    }\n\n    // Get the most recent completed shift for this branch\n    const prevShiftResult = await pool.query(\n      `SELECT id FROM shifts \n       WHERE branch_id = $1 AND status = 'completed'\n       ORDER BY end_time DESC NULLS LAST\n       LIMIT 1`,\n      [branchId]\n    )\n\n    if (prevShiftResult.rows.length === 0) {\n      return NextResponse.json({\n        success: true,\n        incoming_attendant_ids: []\n      })\n    }\n\n    const prevShiftId = prevShiftResult.rows[0].id\n\n    // Get incoming attendants from that shift's shift_readings with nozzle assignments\n    const attendantsResult = await pool.query(\n      `SELECT sr.nozzle_id, sr.incoming_attendant_id \n       FROM shift_readings sr\n       WHERE sr.shift_id = $1 \n         AND sr.incoming_attendant_id IS NOT NULL`,\n      [prevShiftId]\n    )\n\n    const incoming_attendant_ids = [...new Set(attendantsResult.rows.map(r => r.incoming_attendant_id))]\n    \n    // Build nozzle-to-attendant mapping\n    const nozzleAttendantMap: Record<string, string> = {}\n    for (const row of attendantsResult.rows) {\n      nozzleAttendantMap[row.nozzle_id] = row.incoming_attendant_id\n    }\n\n    return NextResponse.json({\n      success: true,\n      incoming_attendant_ids,\n      nozzle_attendant_map: nozzleAttendantMap\n    })\n\n  } catch (error: any) {\n    console.error(\"Error fetching incoming attendants:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch incoming attendants\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAC5C;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;QAElC,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,sDAAsD;QACtD,MAAM,kBAAkB,MAAM,KAAK,KAAK,CACtC,CAAC;;;cAGO,CAAC,EACT;YAAC;SAAS;QAGZ,IAAI,gBAAgB,IAAI,CAAC,MAAM,KAAK,GAAG;YACrC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,wBAAwB,EAAE;YAC5B;QACF;QAEA,MAAM,cAAc,gBAAgB,IAAI,CAAC,EAAE,CAAC,EAAE;QAE9C,mFAAmF;QACnF,MAAM,mBAAmB,MAAM,KAAK,KAAK,CACvC,CAAC;;;iDAG0C,CAAC,EAC5C;YAAC;SAAY;QAGf,MAAM,yBAAyB;eAAI,IAAI,IAAI,iBAAiB,IAAI,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,qBAAqB;SAAG;QAEpG,oCAAoC;QACpC,MAAM,qBAA6C,CAAC;QACpD,KAAK,MAAM,OAAO,iBAAiB,IAAI,CAAE;YACvC,kBAAkB,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI,qBAAqB;QAC/D;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,sBAAsB;QACxB;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAAuC,SAAS,MAAM,OAAO;QAAC,GACvE;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}