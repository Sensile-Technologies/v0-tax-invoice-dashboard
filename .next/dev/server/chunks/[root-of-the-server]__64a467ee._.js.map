{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/mobile/dashboard/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get(\"branch_id\")\n\n    const client = await pool.connect()\n    try {\n      let salesResult\n      if (branchId) {\n        salesResult = await client.query(`\n          SELECT \n            COALESCE(SUM(total_amount), 0) as total_sales,\n            COUNT(*) as total_invoices\n          FROM sales\n          WHERE branch_id = $1 AND DATE(sale_date) = CURRENT_DATE\n        `, [branchId])\n      } else {\n        salesResult = await client.query(`\n          SELECT \n            COALESCE(SUM(total_amount), 0) as total_sales,\n            COUNT(*) as total_invoices\n          FROM sales\n          WHERE DATE(sale_date) = CURRENT_DATE\n        `)\n      }\n\n      let invoiceResult\n      if (branchId) {\n        invoiceResult = await client.query(`\n          SELECT \n            COUNT(CASE WHEN payment_method = 'credit' THEN 1 END) as pending_invoices,\n            COUNT(CASE WHEN payment_method != 'credit' THEN 1 END) as paid_invoices\n          FROM sales\n          WHERE branch_id = $1 AND DATE(sale_date) = CURRENT_DATE\n        `, [branchId])\n      } else {\n        invoiceResult = await client.query(`\n          SELECT \n            COUNT(CASE WHEN payment_method = 'credit' THEN 1 END) as pending_invoices,\n            COUNT(CASE WHEN payment_method != 'credit' THEN 1 END) as paid_invoices\n          FROM sales\n          WHERE DATE(sale_date) = CURRENT_DATE\n        `)\n      }\n\n      const stats = salesResult.rows[0] || { total_sales: 0, total_invoices: 0 }\n      const invoiceStats = invoiceResult.rows[0] || { pending_invoices: 0, paid_invoices: 0 }\n\n      return NextResponse.json({\n        total_sales: Number(stats.total_sales) || 0,\n        total_invoices: Number(stats.total_invoices) || 0,\n        pending_invoices: Number(invoiceStats.pending_invoices) || 0,\n        paid_invoices: Number(invoiceStats.paid_invoices) || 0\n      })\n    } finally {\n      client.release()\n    }\n  } catch (error) {\n    console.error(\"Error fetching mobile dashboard:\", error)\n    return NextResponse.json({\n      total_sales: 0,\n      total_invoices: 0,\n      pending_invoices: 0,\n      paid_invoices: 0\n    })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAC5C;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;QAElC,MAAM,SAAS,MAAM,KAAK,OAAO;QACjC,IAAI;YACF,IAAI;YACJ,IAAI,UAAU;gBACZ,cAAc,MAAM,OAAO,KAAK,CAAC,CAAC;;;;;;QAMlC,CAAC,EAAE;oBAAC;iBAAS;YACf,OAAO;gBACL,cAAc,MAAM,OAAO,KAAK,CAAC,CAAC;;;;;;QAMlC,CAAC;YACH;YAEA,IAAI;YACJ,IAAI,UAAU;gBACZ,gBAAgB,MAAM,OAAO,KAAK,CAAC,CAAC;;;;;;QAMpC,CAAC,EAAE;oBAAC;iBAAS;YACf,OAAO;gBACL,gBAAgB,MAAM,OAAO,KAAK,CAAC,CAAC;;;;;;QAMpC,CAAC;YACH;YAEA,MAAM,QAAQ,YAAY,IAAI,CAAC,EAAE,IAAI;gBAAE,aAAa;gBAAG,gBAAgB;YAAE;YACzE,MAAM,eAAe,cAAc,IAAI,CAAC,EAAE,IAAI;gBAAE,kBAAkB;gBAAG,eAAe;YAAE;YAEtF,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,aAAa,OAAO,MAAM,WAAW,KAAK;gBAC1C,gBAAgB,OAAO,MAAM,cAAc,KAAK;gBAChD,kBAAkB,OAAO,aAAa,gBAAgB,KAAK;gBAC3D,eAAe,OAAO,aAAa,aAAa,KAAK;YACvD;QACF,SAAU;YACR,OAAO,OAAO;QAChB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,aAAa;YACb,gBAAgB;YAChB,kBAAkB;YAClB,eAAe;QACjB;IACF;AACF"}}]
}