{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/db/client.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n});\n\nexport async function query<T = any>(text: string, params?: any[]): Promise<T[]> {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(text, params);\n    return result.rows as T[];\n  } finally {\n    client.release();\n  }\n}\n\nexport async function queryOne<T = any>(text: string, params?: any[]): Promise<T | null> {\n  const rows = await query<T>(text, params);\n  return rows[0] || null;\n}\n\nexport async function execute(text: string, params?: any[]): Promise<number> {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(text, params);\n    return result.rowCount || 0;\n  } finally {\n    client.release();\n  }\n}\n\nexport { pool };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK,sCAAwC,0BAAgC;AAC/E;AAEO,eAAe,MAAe,IAAY,EAAE,MAAc;IAC/D,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,IAAI;IACpB,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe,SAAkB,IAAY,EAAE,MAAc;IAClE,MAAM,OAAO,MAAM,MAAS,MAAM;IAClC,OAAO,IAAI,CAAC,EAAE,IAAI;AACpB;AAEO,eAAe,QAAQ,IAAY,EAAE,MAAc;IACxD,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,QAAQ,IAAI;IAC5B,SAAU;QACR,OAAO,OAAO;IAChB;AACF"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/branches/list/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { query } from \"@/lib/db/client\";\n\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const name = searchParams.get(\"name\");\n    const userId = searchParams.get(\"user_id\");\n    const vendorId = searchParams.get(\"vendor_id\");\n    \n    let vendorFilter = vendorId;\n    \n    // If user_id is provided, find the user's vendor\n    if (userId && !vendorFilter) {\n      // First try: match user email to vendor email\n      const userResult = await query(\n        `SELECT v.id as vendor_id FROM users u \n         JOIN vendors v ON v.email = u.email \n         WHERE u.id = $1`,\n        [userId]\n      );\n      if (userResult && userResult.length > 0) {\n        vendorFilter = userResult[0].vendor_id;\n      }\n      \n      // Second try: get vendor_id from user's staff record → branch → vendor\n      if (!vendorFilter) {\n        const staffResult = await query(\n          `SELECT DISTINCT b.vendor_id FROM staff s\n           JOIN branches b ON s.branch_id = b.id\n           WHERE s.user_id = $1 AND b.vendor_id IS NOT NULL`,\n          [userId]\n        );\n        if (staffResult && staffResult.length > 0) {\n          vendorFilter = staffResult[0].vendor_id;\n        }\n      }\n      \n      // Third try: if still no vendor, get only branches where user has a staff record\n      if (!vendorFilter) {\n        const staffBranchIds = await query(\n          `SELECT branch_id FROM staff WHERE user_id = $1`,\n          [userId]\n        );\n        if (staffBranchIds && staffBranchIds.length > 0) {\n          const branchIds = staffBranchIds.map((s: any) => s.branch_id);\n          const branches = await query(\n            `SELECT * FROM branches WHERE id = ANY($1::uuid[]) AND status IN ('active', 'pending_onboarding') ORDER BY name`,\n            [branchIds]\n          );\n          return NextResponse.json(branches);\n        }\n        \n        // SECURITY: No vendor or staff association found - return empty array\n        // Do NOT fall through to return all branches\n        return NextResponse.json([]);\n      }\n    }\n    \n    // Build query with filters - include both active and pending_onboarding branches\n    let sql = \"SELECT * FROM branches WHERE status IN ('active', 'pending_onboarding')\";\n    const params: any[] = [];\n    let paramIndex = 1;\n    \n    // SECURITY: When user_id was provided but vendor lookup succeeded, \n    // always filter by vendorFilter (which is now set)\n    if (vendorFilter) {\n      sql += ` AND vendor_id = $${paramIndex}`;\n      params.push(vendorFilter);\n      paramIndex++;\n    } else if (userId) {\n      // SECURITY: If user_id was provided but no vendor found and we somehow\n      // got here, return empty array for safety\n      return NextResponse.json([]);\n    }\n    \n    if (name) {\n      sql += ` AND LOWER(name) LIKE LOWER($${paramIndex})`;\n      params.push(`%${name}%`);\n      paramIndex++;\n    }\n    \n    // SECURITY: If no user_id or vendor_id provided, return empty array\n    // to prevent leaking all branches\n    if (!userId && !vendorId) {\n      return NextResponse.json([]);\n    }\n    \n    sql += \" ORDER BY name\";\n    \n    const branches = await query(sql, params);\n    \n    return NextResponse.json(branches);\n  } catch (error: any) {\n    console.error(\"Error fetching branches:\", error);\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEO,eAAe,IAAI,OAAgB;IACxC,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,OAAO,aAAa,GAAG,CAAC;QAC9B,MAAM,SAAS,aAAa,GAAG,CAAC;QAChC,MAAM,WAAW,aAAa,GAAG,CAAC;QAElC,IAAI,eAAe;QAEnB,iDAAiD;QACjD,IAAI,UAAU,CAAC,cAAc;YAC3B,8CAA8C;YAC9C,MAAM,aAAa,MAAM,IAAA,8HAAK,EAC5B,CAAC;;wBAEe,CAAC,EACjB;gBAAC;aAAO;YAEV,IAAI,cAAc,WAAW,MAAM,GAAG,GAAG;gBACvC,eAAe,UAAU,CAAC,EAAE,CAAC,SAAS;YACxC;YAEA,uEAAuE;YACvE,IAAI,CAAC,cAAc;gBACjB,MAAM,cAAc,MAAM,IAAA,8HAAK,EAC7B,CAAC;;2DAEgD,CAAC,EAClD;oBAAC;iBAAO;gBAEV,IAAI,eAAe,YAAY,MAAM,GAAG,GAAG;oBACzC,eAAe,WAAW,CAAC,EAAE,CAAC,SAAS;gBACzC;YACF;YAEA,iFAAiF;YACjF,IAAI,CAAC,cAAc;gBACjB,MAAM,iBAAiB,MAAM,IAAA,8HAAK,EAChC,CAAC,8CAA8C,CAAC,EAChD;oBAAC;iBAAO;gBAEV,IAAI,kBAAkB,eAAe,MAAM,GAAG,GAAG;oBAC/C,MAAM,YAAY,eAAe,GAAG,CAAC,CAAC,IAAW,EAAE,SAAS;oBAC5D,MAAM,WAAW,MAAM,IAAA,8HAAK,EAC1B,CAAC,8GAA8G,CAAC,EAChH;wBAAC;qBAAU;oBAEb,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAC3B;gBAEA,sEAAsE;gBACtE,6CAA6C;gBAC7C,OAAO,gJAAY,CAAC,IAAI,CAAC,EAAE;YAC7B;QACF;QAEA,iFAAiF;QACjF,IAAI,MAAM;QACV,MAAM,SAAgB,EAAE;QACxB,IAAI,aAAa;QAEjB,oEAAoE;QACpE,mDAAmD;QACnD,IAAI,cAAc;YAChB,OAAO,CAAC,kBAAkB,EAAE,YAAY;YACxC,OAAO,IAAI,CAAC;YACZ;QACF,OAAO,IAAI,QAAQ;YACjB,uEAAuE;YACvE,0CAA0C;YAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC,EAAE;QAC7B;QAEA,IAAI,MAAM;YACR,OAAO,CAAC,6BAA6B,EAAE,WAAW,CAAC,CAAC;YACpD,OAAO,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;YACvB;QACF;QAEA,oEAAoE;QACpE,kCAAkC;QAClC,IAAI,CAAC,UAAU,CAAC,UAAU;YACxB,OAAO,gJAAY,CAAC,IAAI,CAAC,EAAE;QAC7B;QAEA,OAAO;QAEP,MAAM,WAAW,MAAM,IAAA,8HAAK,EAAC,KAAK;QAElC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACnE;AACF"}}]
}