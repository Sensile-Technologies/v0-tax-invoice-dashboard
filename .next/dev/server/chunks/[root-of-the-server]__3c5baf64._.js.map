{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/shifts/daily-summary/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { Pool } from \"pg\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n})\n\ninterface ShiftSaleItem {\n  fuel_type: string\n  claimed_quantity: number\n  claimed_amount: number\n  unclaimed_quantity: number\n  unclaimed_amount: number\n}\n\ninterface ShiftSummary {\n  shift_id: string\n  cashier_name: string\n  start_time: string\n  end_time: string | null\n  status: string\n  items: ShiftSaleItem[]\n  totals: {\n    claimed_quantity: number\n    claimed_amount: number\n    unclaimed_quantity: number\n    unclaimed_amount: number\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const branchId = searchParams.get('branch_id')\n    const date = searchParams.get('date')\n    const startDate = searchParams.get('start_date')\n    const endDate = searchParams.get('end_date')\n\n    if (!branchId) {\n      return NextResponse.json(\n        { error: \"branch_id is required\" },\n        { status: 400 }\n      )\n    }\n\n    let startOfPeriod: string\n    let endOfPeriod: string\n\n    if (startDate && endDate) {\n      startOfPeriod = `${startDate}T00:00:00`\n      endOfPeriod = `${endDate}T23:59:59`\n    } else if (date) {\n      startOfPeriod = `${date}T00:00:00`\n      endOfPeriod = `${date}T23:59:59`\n    } else {\n      return NextResponse.json(\n        { error: \"date or (start_date and end_date) are required\" },\n        { status: 400 }\n      )\n    }\n\n    const shiftsQuery = `\n      SELECT \n        s.id,\n        s.start_time,\n        s.end_time,\n        s.status,\n        COALESCE(st.full_name, 'Unknown') as cashier_name\n      FROM shifts s\n      LEFT JOIN staff st ON s.staff_id = st.id\n      WHERE s.branch_id = $1\n        AND s.start_time >= $2\n        AND s.start_time <= $3\n      ORDER BY s.start_time ASC\n    `\n    const shiftsResult = await pool.query(shiftsQuery, [branchId, startOfPeriod, endOfPeriod])\n\n    const shiftSummaries: ShiftSummary[] = []\n\n    for (const shift of shiftsResult.rows) {\n      const nozzleReadingsQuery = `\n        SELECT \n          sr.nozzle_id,\n          sr.opening_reading,\n          sr.closing_reading,\n          i.item_name as fuel_type,\n          i.id as item_id,\n          COALESCE(bi.sale_price, 0) as unit_price\n        FROM shift_readings sr\n        JOIN nozzles n ON sr.nozzle_id = n.id\n        JOIN items i ON n.item_id = i.id\n        LEFT JOIN branch_items bi ON bi.item_id = i.id AND bi.branch_id = $2\n        WHERE sr.shift_id = $1 AND sr.reading_type = 'nozzle'\n      `\n      const readingsResult = await pool.query(nozzleReadingsQuery, [shift.id, branchId])\n\n      const invoicedSalesQuery = `\n        SELECT \n          s.nozzle_id,\n          COALESCE(i.item_name, s.fuel_type) as fuel_type,\n          SUM(s.quantity) as invoiced_quantity,\n          SUM(s.total_amount) as invoiced_amount\n        FROM sales s\n        LEFT JOIN items i ON s.item_id = i.id\n        WHERE s.shift_id = $1 AND s.nozzle_id IS NOT NULL\n          AND (s.source_system IS NULL OR s.source_system NOT IN ('meter_diff_bulk', 'PTS'))\n          AND s.is_automated = false\n        GROUP BY s.nozzle_id, COALESCE(i.item_name, s.fuel_type)\n      `\n      const invoicedResult = await pool.query(invoicedSalesQuery, [shift.id])\n      const invoicedMap = new Map<string, { quantity: number, amount: number }>()\n      \n      for (const row of invoicedResult.rows) {\n        const key = row.nozzle_id\n        invoicedMap.set(key, {\n          quantity: parseFloat(row.invoiced_quantity) || 0,\n          amount: parseFloat(row.invoiced_amount) || 0\n        })\n      }\n\n      const fuelTypeData = new Map<string, { claimed: { quantity: number, amount: number }, unclaimed: { quantity: number, amount: number }, unitPrice: number }>()\n\n      for (const reading of readingsResult.rows) {\n        const openingReading = parseFloat(reading.opening_reading) || 0\n        const closingReading = parseFloat(reading.closing_reading) || 0\n        const meterDifference = closingReading - openingReading\n        const branchItemPrice = parseFloat(reading.unit_price) || 0\n\n        const invoiced = invoicedMap.get(reading.nozzle_id)\n        const claimedQty = invoiced?.quantity || 0\n        const claimedAmt = invoiced?.amount || 0\n        const unclaimedQty = Math.max(0, meterDifference - claimedQty)\n\n        const rawFuelType = reading.fuel_type || \"Other\"\n        const fuelType = rawFuelType.charAt(0).toUpperCase() + rawFuelType.slice(1).toLowerCase()\n\n        const existing = fuelTypeData.get(fuelType) || { \n          claimed: { quantity: 0, amount: 0 }, \n          unclaimed: { quantity: 0, amount: 0 },\n          unitPrice: branchItemPrice\n        }\n\n        existing.claimed.quantity += claimedQty\n        existing.claimed.amount += claimedAmt\n        existing.unclaimed.quantity += unclaimedQty\n        \n        if (branchItemPrice > 0) {\n          existing.unitPrice = branchItemPrice\n        }\n\n        fuelTypeData.set(fuelType, existing)\n      }\n\n      const items: ShiftSaleItem[] = []\n      let totalClaimedQty = 0\n      let totalClaimedAmt = 0\n      let totalUnclaimedQty = 0\n      let totalUnclaimedAmt = 0\n\n      for (const [fuelType, data] of fuelTypeData) {\n        const unitPrice = data.unitPrice\n        const unclaimedAmt = data.unclaimed.quantity * unitPrice\n\n        items.push({\n          fuel_type: fuelType,\n          claimed_quantity: data.claimed.quantity,\n          claimed_amount: data.claimed.amount,\n          unclaimed_quantity: data.unclaimed.quantity,\n          unclaimed_amount: unclaimedAmt\n        })\n\n        totalClaimedQty += data.claimed.quantity\n        totalClaimedAmt += data.claimed.amount\n        totalUnclaimedQty += data.unclaimed.quantity\n        totalUnclaimedAmt += unclaimedAmt\n      }\n\n      items.sort((a, b) => a.fuel_type.localeCompare(b.fuel_type))\n\n      shiftSummaries.push({\n        shift_id: shift.id,\n        cashier_name: shift.cashier_name,\n        start_time: shift.start_time,\n        end_time: shift.end_time,\n        status: shift.status,\n        items,\n        totals: {\n          claimed_quantity: totalClaimedQty,\n          claimed_amount: totalClaimedAmt,\n          unclaimed_quantity: totalUnclaimedQty,\n          unclaimed_amount: totalUnclaimedAmt\n        }\n      })\n    }\n\n    const grandTotals = {\n      claimed_quantity: shiftSummaries.reduce((sum, s) => sum + s.totals.claimed_quantity, 0),\n      claimed_amount: shiftSummaries.reduce((sum, s) => sum + s.totals.claimed_amount, 0),\n      unclaimed_quantity: shiftSummaries.reduce((sum, s) => sum + s.totals.unclaimed_quantity, 0),\n      unclaimed_amount: shiftSummaries.reduce((sum, s) => sum + s.totals.unclaimed_amount, 0)\n    }\n\n    const productSummary = new Map<string, ShiftSaleItem>()\n    for (const shift of shiftSummaries) {\n      for (const item of shift.items) {\n        const existing = productSummary.get(item.fuel_type) || {\n          fuel_type: item.fuel_type,\n          claimed_quantity: 0,\n          claimed_amount: 0,\n          unclaimed_quantity: 0,\n          unclaimed_amount: 0\n        }\n        existing.claimed_quantity += item.claimed_quantity\n        existing.claimed_amount += item.claimed_amount\n        existing.unclaimed_quantity += item.unclaimed_quantity\n        existing.unclaimed_amount += item.unclaimed_amount\n        productSummary.set(item.fuel_type, existing)\n      }\n    }\n    const productTotals = Array.from(productSummary.values()).sort((a, b) => a.fuel_type.localeCompare(b.fuel_type))\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        shifts: shiftSummaries,\n        grandTotals,\n        productTotals\n      }\n    })\n\n  } catch (error: any) {\n    console.error(\"Error fetching daily shift summary:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch daily shift summary\", details: error.message },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}