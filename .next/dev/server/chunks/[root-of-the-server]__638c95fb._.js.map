{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/db/client.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n});\n\nexport async function query<T = any>(text: string, params?: any[]): Promise<T[]> {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(text, params);\n    return result.rows as T[];\n  } finally {\n    client.release();\n  }\n}\n\nexport async function queryOne<T = any>(text: string, params?: any[]): Promise<T | null> {\n  const rows = await query<T>(text, params);\n  return rows[0] || null;\n}\n\nexport async function execute(text: string, params?: any[]): Promise<number> {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(text, params);\n    return result.rowCount || 0;\n  } finally {\n    client.release();\n  }\n}\n\nexport { pool };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK,sCAAwC,0BAAgC;AAC/E;AAEO,eAAe,MAAe,IAAY,EAAE,MAAc;IAC/D,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,IAAI;IACpB,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe,SAAkB,IAAY,EAAE,MAAc;IAClE,MAAM,OAAO,MAAM,MAAS,MAAM;IAClC,OAAO,IAAI,CAAC,EAAE,IAAI;AACpB;AAEO,eAAe,QAAQ,IAAY,EAAE,MAAc;IACxD,MAAM,SAAS,MAAM,KAAK,OAAO;IACjC,IAAI;QACF,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,MAAM;QACxC,OAAO,OAAO,QAAQ,IAAI;IAC5B,SAAU;QACR,OAAO,OAAO;IAChB;AACF"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/db/index.ts"],"sourcesContent":["export * from './client';\n"],"names":[],"mappings":";AAAA"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/kra/saved-data/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { query } from \"@/lib/db\"\nimport { cookies } from \"next/headers\"\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const type = searchParams.get(\"type\")\n    \n    const cookieStore = await cookies()\n    const branchId = cookieStore.get(\"branch_id\")?.value\n    \n    let bhfId = null\n    \n    if (branchId) {\n      const branchResult = await query(\n        \"SELECT bhf_id FROM branches WHERE id = $1\",\n        [branchId]\n      )\n      if (branchResult.length > 0) {\n        bhfId = branchResult[0].bhf_id\n      }\n    }\n    \n    if (!bhfId) {\n      const defaultBranch = await query(\n        \"SELECT bhf_id FROM branches WHERE bhf_id IS NOT NULL AND status = 'active' LIMIT 1\"\n      )\n      if (defaultBranch.length > 0) {\n        bhfId = defaultBranch[0].bhf_id\n      }\n    }\n\n    if (type === \"codelist\") {\n      // First try to get data for the specific branch\n      let result = bhfId \n        ? await query(\n            `SELECT cd_cls, cd, cd_nm, cd_desc, use_yn, updated_at \n             FROM kra_codelists \n             WHERE bhf_id = $1 \n             ORDER BY cd_cls, cd`,\n            [bhfId]\n          )\n        : []\n      \n      // If no data for this branch, get data from any branch (codelists are shared)\n      if (result.length === 0) {\n        result = await query(\n          `SELECT DISTINCT ON (cd_cls, cd) cd_cls, cd, cd_nm, cd_desc, use_yn, updated_at \n           FROM kra_codelists \n           ORDER BY cd_cls, cd, updated_at DESC`\n        )\n      }\n      \n      return NextResponse.json({ \n        data: result,\n        bhf_id: bhfId,\n        source: result.length > 0 ? \"database\" : \"none\"\n      })\n    }\n    \n    if (type === \"classifications\") {\n      const result = bhfId \n        ? await query(\n            `SELECT item_cls_cd, item_cls_nm, item_cls_lvl, tax_ty_cd, use_yn, updated_at \n             FROM kra_item_classifications \n             WHERE bhf_id = $1 \n             ORDER BY item_cls_cd`,\n            [bhfId]\n          )\n        : []\n      \n      return NextResponse.json({ \n        data: result,\n        bhf_id: bhfId,\n        source: result.length > 0 ? \"database\" : \"none\"\n      })\n    }\n\n    return NextResponse.json({ error: \"Invalid type parameter\" }, { status: 400 })\n  } catch (error) {\n    console.error(\"Error fetching saved KRA data:\", error)\n    return NextResponse.json({ error: \"Failed to fetch data\" }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;;;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,OAAO,aAAa,GAAG,CAAC;QAE9B,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,WAAW,YAAY,GAAG,CAAC,cAAc;QAE/C,IAAI,QAAQ;QAEZ,IAAI,UAAU;YACZ,MAAM,eAAe,MAAM,IAAA,8HAAK,EAC9B,6CACA;gBAAC;aAAS;YAEZ,IAAI,aAAa,MAAM,GAAG,GAAG;gBAC3B,QAAQ,YAAY,CAAC,EAAE,CAAC,MAAM;YAChC;QACF;QAEA,IAAI,CAAC,OAAO;YACV,MAAM,gBAAgB,MAAM,IAAA,8HAAK,EAC/B;YAEF,IAAI,cAAc,MAAM,GAAG,GAAG;gBAC5B,QAAQ,aAAa,CAAC,EAAE,CAAC,MAAM;YACjC;QACF;QAEA,IAAI,SAAS,YAAY;YACvB,gDAAgD;YAChD,IAAI,SAAS,QACT,MAAM,IAAA,8HAAK,EACT,CAAC;;;gCAGmB,CAAC,EACrB;gBAAC;aAAM,IAET,EAAE;YAEN,8EAA8E;YAC9E,IAAI,OAAO,MAAM,KAAK,GAAG;gBACvB,SAAS,MAAM,IAAA,8HAAK,EAClB,CAAC;;+CAEoC,CAAC;YAE1C;YAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,MAAM;gBACN,QAAQ;gBACR,QAAQ,OAAO,MAAM,GAAG,IAAI,aAAa;YAC3C;QACF;QAEA,IAAI,SAAS,mBAAmB;YAC9B,MAAM,SAAS,QACX,MAAM,IAAA,8HAAK,EACT,CAAC;;;iCAGoB,CAAC,EACtB;gBAAC;aAAM,IAET,EAAE;YAEN,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,MAAM;gBACN,QAAQ;gBACR,QAAQ,OAAO,MAAM,GAAG,IAAI,aAAa;YAC3C;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAyB,GAAG;YAAE,QAAQ;QAAI;IAC9E,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAuB,GAAG;YAAE,QAAQ;QAAI;IAC5E;AACF"}}]
}