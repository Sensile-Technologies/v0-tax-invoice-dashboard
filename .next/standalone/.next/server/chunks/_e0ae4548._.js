module.exports=[32588,e=>e.a(async(t,r)=>{try{var a=e.i(89171),n=e.i(70038),s=e.i(90793),i=e.i(93458),o=t([n,s]);async function d(){try{let e=(await (0,i.cookies)()).get("user_session");if(!e?.value)return null;let t=JSON.parse(e.value);return{id:t.id,branch_id:t.branch_id}}catch{return null}}async function c(e){let t=await (0,s.query)("SELECT branch_id FROM staff WHERE user_id = $1 LIMIT 1",[e]);if(t&&t.length>0)return t[0].branch_id;let r=await (0,s.query)("SELECT id FROM branches WHERE user_id = $1 LIMIT 1",[e]);return r&&r.length>0?r[0].id:null}async function u(e){try{let t=await d();if(!t)return a.NextResponse.json({success:!1,error:"Unauthorized"},{status:401});let r=t.branch_id||await c(t.id);if(!r)return a.NextResponse.json({success:!1,error:"No branch found for user"},{status:403});let{searchParams:n}=new URL(e.url),i=n.get("purchase_order_id");if(i){let e=await (0,s.query)("SELECT id FROM purchase_orders WHERE id = $1 AND branch_id = $2",[i,r]);if(!e||0===e.length)return a.NextResponse.json({success:!1,error:"Purchase order not found"},{status:404});let t=await (0,s.query)(`SELECT poi.item_id, poi.quantity, poi.unit_price, poi.total_amount,
                i.item_name, i.quantity_unit
         FROM purchase_order_items poi 
         JOIN items i ON poi.item_id = i.id 
         WHERE poi.purchase_order_id = $1`,[i]),n=t.map(e=>e.item_id),o=[],d=[],c=[];if(n.length>0){let e=(o=await (0,s.query)(`SELECT t.*, i.item_name 
           FROM tanks t 
           LEFT JOIN items i ON t.item_id = i.id 
           WHERE t.branch_id = $1 AND t.item_id = ANY($2::uuid[])
           ORDER BY t.tank_name`,[r,n])).map(e=>e.id);e.length>0&&(d=await (0,s.query)(`SELECT DISTINCT d.*, t.tank_name,
             COALESCE(
               (SELECT meter_reading_after 
                FROM po_acceptance_dispenser_readings pdr
                JOIN purchase_order_acceptances poa ON pdr.acceptance_id = poa.id
                WHERE pdr.dispenser_id = d.id 
                ORDER BY poa.acceptance_timestamp DESC 
                LIMIT 1),
               0
             ) as last_meter_reading
             FROM dispensers d 
             LEFT JOIN tanks t ON d.tank_id = t.id
             LEFT JOIN dispenser_tanks dt ON d.id = dt.dispenser_id
             WHERE d.branch_id = $1 
               AND (d.tank_id = ANY($2::uuid[]) OR dt.tank_id = ANY($2::uuid[]))
             ORDER BY d.dispenser_number`,[r,e]))}return c=await (0,s.query)(`SELECT n.*, d.dispenser_number, i.item_name as fuel_name,
         COALESCE(
           (SELECT meter_reading_after 
            FROM po_acceptance_nozzle_readings pnr
            JOIN purchase_order_acceptances poa ON pnr.acceptance_id = poa.id
            WHERE pnr.nozzle_id = n.id 
            ORDER BY poa.acceptance_timestamp DESC 
            LIMIT 1),
           n.initial_meter_reading,
           0
         ) as last_meter_reading
         FROM nozzles n
         LEFT JOIN dispensers d ON n.dispenser_id = d.id
         LEFT JOIN items i ON n.item_id = i.id
         WHERE n.branch_id = $1 AND n.status = 'active'
         ORDER BY d.dispenser_number, n.nozzle_number`,[r]),a.NextResponse.json({success:!0,tanks:o,dispensers:d,nozzles:c,items:t})}let o=await (0,s.query)(`SELECT 
        po.*,
        vp.name as supplier_name,
        tp.name as transporter_name,
        u.username as created_by_name,
        (SELECT COUNT(*) FROM purchase_order_items WHERE purchase_order_id = po.id) as item_count,
        (SELECT COALESCE(SUM(total_amount), 0) FROM purchase_order_items WHERE purchase_order_id = po.id) as total_amount
       FROM purchase_orders po
       LEFT JOIN vendor_partners vp ON po.supplier_id = vp.id
       LEFT JOIN vendor_partners tp ON po.transporter_id = tp.id
       LEFT JOIN users u ON po.created_by = u.id
       WHERE po.branch_id = $1 AND po.status = 'pending' AND po.approval_status = 'approved'
       ORDER BY po.issued_at DESC`,[r]);return a.NextResponse.json({success:!0,data:o})}catch(e){return console.error("Error fetching pending purchase orders:",e),a.NextResponse.json({success:!1,error:"Failed to fetch purchase orders"},{status:500})}}async function p(e){try{let t=await d();if(!t)return a.NextResponse.json({success:!1,error:"Unauthorized"},{status:401});let r=t.branch_id||await c(t.id);if(!r)return a.NextResponse.json({success:!1,error:"No branch found for user"},{status:403});let{purchase_order_id:n,bowser_volume:i,dips_mm:o,acceptance_timestamp:u,tank_readings:p,dispenser_readings:l,nozzle_readings:_,remarks:E}=await e.json();if(!n)return a.NextResponse.json({success:!1,error:"Purchase order ID is required"},{status:400});if(null==i)return a.NextResponse.json({success:!1,error:"Bowser volume is required"},{status:400});let h=await (0,s.query)(`SELECT po.*, b.id as branch_id FROM purchase_orders po 
       JOIN branches b ON po.branch_id = b.id
       WHERE po.id = $1 AND po.status = 'pending' AND po.branch_id = $2`,[n,r]);if(!h||0===h.length)return a.NextResponse.json({success:!1,error:"Purchase order not found or not assigned to your branch"},{status:404});let R=h[0].branch_id;if(p&&Array.isArray(p))for(let e of p){let t=await (0,s.query)("SELECT tank_name, capacity FROM tanks WHERE id = $1",[e.tank_id]);if(t&&t.length>0){let r=t[0],n=parseFloat(e.volume_after)||0,s=parseFloat(r.capacity)||0;if(s>0&&n>s)return a.NextResponse.json({success:!1,error:`${r.tank_name}: Volume after (${n}L) exceeds tank capacity (${s}L)`},{status:400})}}let f=0,m=0,N=0;if(p&&Array.isArray(p))for(let e of p){let t=(parseFloat(e.volume_after)||0)-(parseFloat(e.volume_before)||0);f+=t}if(l&&Array.isArray(l))for(let e of l){let t=(parseFloat(e.meter_reading_after)||0)-(parseFloat(e.meter_reading_before)||0);m+=t}if(_&&Array.isArray(_))for(let e of _){let t=(parseFloat(e.meter_reading_after)||0)-(parseFloat(e.meter_reading_before)||0);N+=t}let y=parseFloat(i)||0,O=_&&_.length>0?N:m,g=f+O-y,v=await s.pool.connect();try{await v.query("BEGIN");let e=await v.query(`INSERT INTO purchase_order_acceptances 
         (purchase_order_id, branch_id, accepted_by, bowser_volume, dips_mm, total_variance, remarks, acceptance_timestamp)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
         RETURNING *`,[n,R,t.id,y,o||null,g,E||null,u||new Date().toISOString()]),r=e.rows[0].id;if(p&&Array.isArray(p))for(let e of p){let a=parseFloat(e.volume_before)||0,s=parseFloat(e.volume_after)||0,i=s-a;await v.query(`INSERT INTO po_acceptance_tank_readings 
             (acceptance_id, tank_id, volume_before, volume_after)
             VALUES ($1, $2, $3, $4)`,[r,e.tank_id,a,s]),await v.query(`UPDATE tanks 
             SET current_stock = $1, updated_at = NOW()
             WHERE id = $2 AND branch_id = $3`,[s,e.tank_id,R]),i>0&&await v.query(`INSERT INTO stock_adjustments 
               (branch_id, tank_id, adjustment_type, quantity, previous_stock, new_stock, reason, approved_by, approval_status)
               VALUES ($1, $2, 'purchase_receive', $3, $4, $5, $6, $7, 'approved')`,[R,e.tank_id,i,a,s,`Purchase order delivery accepted (PO: ${n.substring(0,8)})`,t.id])}if(l&&Array.isArray(l))for(let e of l)await v.query(`INSERT INTO po_acceptance_dispenser_readings 
             (acceptance_id, dispenser_id, meter_reading_before, meter_reading_after)
             VALUES ($1, $2, $3, $4)`,[r,e.dispenser_id,e.meter_reading_before,e.meter_reading_after]);if(_&&Array.isArray(_))for(let e of _)await v.query(`INSERT INTO po_acceptance_nozzle_readings 
             (acceptance_id, nozzle_id, meter_reading_before, meter_reading_after)
             VALUES ($1, $2, $3, $4)`,[r,e.nozzle_id,e.meter_reading_before,e.meter_reading_after]);return await v.query("UPDATE purchase_orders SET status = 'accepted', accepted_at = NOW(), updated_at = NOW() WHERE id = $1",[n]),await v.query("COMMIT"),a.NextResponse.json({success:!0,data:{acceptance:e.rows[0],variance:g,tank_variance:f,dispenser_variance:m,nozzle_variance:N},message:"Purchase order accepted successfully"})}catch(e){throw await v.query("ROLLBACK"),e}finally{v.release()}}catch(e){return console.error("Error accepting purchase order:",e),a.NextResponse.json({success:!1,error:"Failed to accept purchase order"},{status:500})}}[n,s]=o.then?(await o)():o,e.s(["GET",()=>u,"POST",()=>p]),r()}catch(e){r(e)}},!1),39752,e=>e.a(async(t,r)=>{try{var a=e.i(47909),n=e.i(74017),s=e.i(96250),i=e.i(59756),o=e.i(61916),d=e.i(14444),c=e.i(37092),u=e.i(69741),p=e.i(16795),l=e.i(87718),_=e.i(95169),E=e.i(47587),h=e.i(66012),R=e.i(70101),f=e.i(26937),m=e.i(10372),N=e.i(93695);e.i(52474);var y=e.i(220),O=e.i(32588),g=t([O]);[O]=g.then?(await g)():g;let T=new a.AppRouteRouteModule({definition:{kind:n.RouteKind.APP_ROUTE,page:"/api/purchases/accept/route",pathname:"/api/purchases/accept",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/purchases/accept/route.ts",nextConfigOutput:"standalone",userland:O}),{workAsyncStorage:b,workUnitAsyncStorage:A,serverHooks:C}=T;function v(){return(0,s.patchFetch)({workAsyncStorage:b,workUnitAsyncStorage:A})}async function w(e,t,r){T.isDev&&(0,i.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let a="/api/purchases/accept/route";a=a.replace(/\/index$/,"")||"/";let s=await T.prepare(e,t,{srcPage:a,multiZoneDraftMode:!1});if(!s)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:O,params:g,nextConfig:v,parsedUrl:w,isDraftMode:b,prerenderManifest:A,routerServerContext:C,isOnDemandRevalidate:$,revalidateOnlyGenerated:S,resolvedPathname:I,clientReferenceManifest:x,serverActionsManifest:L}=s,F=(0,u.normalizeAppPath)(a),k=!!(A.dynamicRoutes[F]||A.routes[I]),q=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,w,!1):t.end("This page could not be found"),null);if(k&&!b){let e=!!A.routes[I],t=A.dynamicRoutes[F];if(t&&!1===t.fallback&&!e){if(v.experimental.adapterPath)return await q();throw new N.NoFallbackError}}let M=null;!k||T.isDev||b||(M=I,M="/index"===M?"/":M);let D=!0===T.isDev||!k,H=k&&!D;L&&x&&(0,d.setReferenceManifestsSingleton)({page:a,clientReferenceManifest:x,serverActionsManifest:L,serverModuleMap:(0,c.createServerModuleMap)({serverActionsManifest:L})});let P=e.method||"GET",U=(0,o.getTracer)(),j=U.getActiveScopeSpan(),W={params:g,prerenderManifest:A,renderOpts:{experimental:{authInterrupts:!!v.experimental.authInterrupts},cacheComponents:!!v.cacheComponents,supportsDynamicResponse:D,incrementalCache:(0,i.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:v.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,a)=>T.onRequestError(e,t,a,C)},sharedContext:{buildId:O}},z=new p.NodeNextRequest(e),B=new p.NodeNextResponse(t),J=l.NextRequestAdapter.fromNodeNextRequest(z,(0,l.signalFromNodeResponse)(t));try{let s=async e=>T.handle(J,W).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=U.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==_.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=r.get("next.route");if(n){let t=`${P} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":t}),e.updateName(t)}else e.updateName(`${P} ${a}`)}),d=!!(0,i.getRequestMeta)(e,"minimalMode"),c=async i=>{var o,c;let u=async({previousCacheEntry:n})=>{try{if(!d&&$&&S&&!n)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let a=await s(i);e.fetchMetrics=W.renderOpts.fetchMetrics;let o=W.renderOpts.pendingWaitUntil;o&&r.waitUntil&&(r.waitUntil(o),o=void 0);let c=W.renderOpts.collectedTags;if(!k)return await (0,h.sendResponse)(z,B,a,W.renderOpts.pendingWaitUntil),null;{let e=await a.blob(),t=(0,R.toNodeOutgoingHttpHeaders)(a.headers);c&&(t[m.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==W.renderOpts.collectedRevalidate&&!(W.renderOpts.collectedRevalidate>=m.INFINITE_CACHE)&&W.renderOpts.collectedRevalidate,n=void 0===W.renderOpts.collectedExpire||W.renderOpts.collectedExpire>=m.INFINITE_CACHE?void 0:W.renderOpts.collectedExpire;return{value:{kind:y.CachedRouteKind.APP_ROUTE,status:a.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:n}}}}catch(t){throw(null==n?void 0:n.isStale)&&await T.onRequestError(e,t,{routerKind:"App Router",routePath:a,routeType:"route",revalidateReason:(0,E.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:$})},C),t}},p=await T.handleResponse({req:e,nextConfig:v,cacheKey:M,routeKind:n.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:A,isRoutePPREnabled:!1,isOnDemandRevalidate:$,revalidateOnlyGenerated:S,responseGenerator:u,waitUntil:r.waitUntil,isMinimalMode:d});if(!k)return null;if((null==p||null==(o=p.value)?void 0:o.kind)!==y.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==p||null==(c=p.value)?void 0:c.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});d||t.setHeader("x-nextjs-cache",$?"REVALIDATED":p.isMiss?"MISS":p.isStale?"STALE":"HIT"),b&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let l=(0,R.fromNodeOutgoingHttpHeaders)(p.value.headers);return d&&k||l.delete(m.NEXT_CACHE_TAGS_HEADER),!p.cacheControl||t.getHeader("Cache-Control")||l.get("Cache-Control")||l.set("Cache-Control",(0,f.getCacheControlHeader)(p.cacheControl)),await (0,h.sendResponse)(z,B,new Response(p.value.body,{headers:l,status:p.value.status||200})),null};j?await c(j):await U.withPropagatedContext(e.headers,()=>U.trace(_.BaseServerSpan.handleRequest,{spanName:`${P} ${a}`,kind:o.SpanKind.SERVER,attributes:{"http.method":P,"http.target":e.url}},c))}catch(t){if(t instanceof N.NoFallbackError||await T.onRequestError(e,t,{routerKind:"App Router",routePath:F,routeType:"route",revalidateReason:(0,E.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:$})}),k)throw t;return await (0,h.sendResponse)(z,B,new Response(null,{status:500})),null}}e.s(["handler",()=>w,"patchFetch",()=>v,"routeModule",()=>T,"serverHooks",()=>C,"workAsyncStorage",()=>b,"workUnitAsyncStorage",()=>A]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=_e0ae4548._.js.map