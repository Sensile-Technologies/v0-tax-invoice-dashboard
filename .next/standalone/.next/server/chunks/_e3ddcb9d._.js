module.exports=[46534,e=>e.a(async(t,a)=>{try{var s=e.i(89171),r=e.i(70038),n=e.i(90793),o=e.i(65488),i=t([r,n]);async function d(e,t,a=3){let s=null;for(let r=1;r<=a;r++)try{let a=new AbortController,s=setTimeout(()=>a.abort(),2e4),r=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t),signal:a.signal});return clearTimeout(s),{response:await r.json(),statusCode:r.status}}catch(e){if(s=e,console.log(`[Stock Adjust] KRA attempt ${r}/${a} failed: ${e.message}`),r<a){let e=Math.min(1e3*Math.pow(2,r-1),5e3);await new Promise(t=>setTimeout(t,e))}}return{response:{resultCd:s?.name==="AbortError"?"TIMEOUT":"NETWORK_ERROR",resultMsg:s?.name==="AbortError"?`Request timed out after ${a} attempts`:`Network error after ${a} attempts: ${s?.message}`,resultDt:new Date().toISOString()},statusCode:0}}function u(e=new Date){let t=e.getFullYear(),a=String(e.getMonth()+1).padStart(2,"0"),s=String(e.getDate()).padStart(2,"0");return`${t}${a}${s}`}async function l(e){let t=await (0,n.getClient)();try{let a,{branch_id:r,tank_id:n,adjustment_type:i,quantity:l,reason:c,approved_by:p,sync_to_kra:m=!0}=await e.json();if(!r||!n||!i||void 0===l)return s.NextResponse.json({error:"branch_id, tank_id, adjustment_type, and quantity are required"},{status:400});if(!["increase","decrease","set"].includes(i))return s.NextResponse.json({error:"adjustment_type must be 'increase', 'decrease', or 'set'"},{status:400});await t.query("BEGIN");let _=await t.query(`
      SELECT b.id, b.kra_pin, b.bhf_id, b.sr_number,
             COALESCE(b.server_address, '5.189.171.160') as server_address,
             COALESCE(b.server_port, '8088') as server_port,
             (SELECT v.kra_pin FROM vendors v WHERE v.id = b.vendor_id) as vendor_kra_pin
      FROM branches b
      WHERE b.id = $1
      FOR UPDATE OF b
    `,[r]);if(0===_.rows.length)return await t.query("ROLLBACK"),s.NextResponse.json({error:"Branch not found"},{status:404});let y=_.rows[0],R=y.kra_pin||y.vendor_kra_pin,E=y.bhf_id||"00",h=await t.query(`
      SELECT t.*, 
             (SELECT i.item_code FROM items i WHERE i.id = t.item_id) as item_code,
             (SELECT i.class_code FROM items i WHERE i.id = t.item_id) as class_code,
             (SELECT i.item_name FROM items i WHERE i.id = t.item_id) as item_name,
             (SELECT i.package_unit FROM items i WHERE i.id = t.item_id) as package_unit,
             (SELECT i.quantity_unit FROM items i WHERE i.id = t.item_id) as quantity_unit
      FROM tanks t
      WHERE t.id = $1
      FOR UPDATE OF t
    `,[n]);if(0===h.rows.length)return await t.query("ROLLBACK"),s.NextResponse.json({error:"Tank not found"},{status:404});let g=h.rows[0],k=parseFloat(g.current_stock)||0,f=parseFloat(g.capacity)||0;if(a="increase"===i?k+l:"decrease"===i?Math.max(0,k-l):l,f>0&&a>f){await t.query("ROLLBACK");let e=f-k;return s.NextResponse.json({success:!1,error:`Cannot adjust stock. Tank capacity is ${f}L. Adjustment would result in ${a.toFixed(2)}L which exceeds capacity. Available space: ${e.toFixed(2)}L`},{status:400})}let $=Math.abs(a-k);if(0===$)return await t.query("ROLLBACK"),s.NextResponse.json({success:!0,data:{tankId:n,adjustmentType:i,previousStock:k,adjustedQuantity:0,newStock:k,fuelType:g.fuel_type},kraSync:null,message:"No adjustment needed - stock unchanged"});let A=null,w=null;if(m&&!R)return await t.query("ROLLBACK"),s.NextResponse.json({success:!1,error:"Branch KRA configuration is missing (no KRA PIN). Please configure KRA settings before adjusting stock."},{status:400});if(m&&R){w=(y.sr_number||0)+1;let e=(0,o.buildKraBaseUrl)(y.server_address,y.server_port),i=g.item_code||g.kra_item_cd||`FUEL${n.substring(0,8)}`,l=g.class_code||"5059690800",p=g.item_name||g.fuel_type||"Fuel",m={tin:R,bhfId:E,sarNo:w,orgSarNo:0,regTyCd:"M",custTin:null,custNm:null,custBhfId:null,sarTyCd:"06",ocrnDt:u(),totItemCnt:1,totTaxblAmt:0,totTaxAmt:0,totAmt:0,remark:c||`Stock adjustment: ${k} -> ${a}`,regrId:"Admin",regrNm:"Admin",modrNm:"Admin",modrId:"Admin",itemList:[{itemSeq:1,itemCd:i,itemClsCd:l,itemNm:p,bcd:null,pkgUnitCd:g.package_unit||"NT",pkg:Math.ceil($),qtyUnitCd:g.quantity_unit||"U",qty:$,itemExprDt:null,prc:0,splyAmt:0,totDcAmt:0,taxblAmt:0,taxTyCd:"B",taxAmt:0,totAmt:0}]};console.log(`[Stock Adjust] Calling saveStockItems for tank ${n}, sarNo: ${w}`);let{response:_,statusCode:h}=await d(`${e}/stock/saveStockItems`,m);await t.query(`
        INSERT INTO branch_logs (branch_id, log_type, endpoint, request_payload, response_payload, status)
        VALUES ($1, $2, $3, $4, $5, $6)
      `,[r,"kra_stock_sync","/stock/saveStockItems",JSON.stringify(m),JSON.stringify(_),_?.resultCd==="000"||_?.resultCd==="0"?"success":"error"]);let f=_?.resultCd==="000"||_?.resultCd==="0";if(!f)return await t.query("ROLLBACK"),console.error("[Stock Adjust] saveStockItems failed:",_),s.NextResponse.json({success:!1,error:_?.resultMsg||"Failed to sync stock adjustment to KRA",kraResponse:_},{status:500});let S={tin:R,bhfId:E,itemCd:i,rsdQty:a,regrId:"Admin",regrNm:"Admin",modrNm:"Admin",modrId:"Admin"};console.log(`[Stock Adjust] Calling saveStockMaster for item ${i}, newStock: ${a}`);let{response:C,statusCode:v}=await d(`${e}/stockMaster/saveStockMaster`,S);await t.query(`
        INSERT INTO branch_logs (branch_id, log_type, endpoint, request_payload, response_payload, status)
        VALUES ($1, $2, $3, $4, $5, $6)
      `,[r,"kra_stock_sync","/stockMaster/saveStockMaster",JSON.stringify(S),JSON.stringify(C),C?.resultCd==="000"||C?.resultCd==="0"?"success":"error"]);let T=C?.resultCd==="000"||C?.resultCd==="0";A={success:f&&T,saveStockItems:_,saveStockMaster:C},T||console.warn("[Stock Adjust] saveStockMaster failed but saveStockItems succeeded - continuing with adjustment"),await t.query(`
        INSERT INTO stock_movements (
          branch_id, tin, bhf_id, sar_no, org_sar_no, reg_ty_cd, 
          cust_tin, cust_bhf_id, cust_nm, sar_ty_cd, ocrn_dt,
          tot_item_cnt, tot_taxbl_amt, tot_tax_amt, tot_amt, remark,
          regr_id, regr_nm, modr_id, modr_nm,
          kra_status, kra_response, kra_synced_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
          $12, $13, $14, $15, $16, $17, $18, $19, $20,
          $21, $22, $23
        )
      `,[r,R,E,w,0,"M",null,null,null,"06",u(),1,0,0,0,c||`Stock adjustment: ${k} -> ${a}`,"Admin","Admin","Admin","Admin",f?"success":"failed",JSON.stringify(_),f?new Date:null])}return w&&await t.query("UPDATE branches SET sr_number = $1, updated_at = NOW() WHERE id = $2",[w,r]),await t.query("UPDATE tanks SET current_stock = $1, kra_sync_status = $2, last_kra_synced_stock = $3, updated_at = NOW() WHERE id = $4",[a,A?.success?"synced":m?"failed":"pending",A?.success?a:g.last_kra_synced_stock,n]),await t.query(`INSERT INTO stock_adjustments (branch_id, tank_id, adjustment_type, quantity, previous_stock, new_stock, reason, approved_by, approval_status, kra_sync_status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,[r,n,i,$,k,a,c||"Manual adjustment",p||"System","approved",A?.success?"synced":"pending"]),await t.query("COMMIT"),console.log(`[Stock Adjust] Successfully adjusted tank ${n}: ${k} -> ${a}`),s.NextResponse.json({success:!0,data:{tankId:n,adjustmentType:i,previousStock:k,adjustedQuantity:$,newStock:a,fuelType:g.fuel_type},kraSync:A?{synced:A.success,error:A.success?void 0:"KRA sync completed with warnings"}:null})}catch(e){return await t.query("ROLLBACK"),console.error("[Stock Adjust API] Error:",e),s.NextResponse.json({error:"Failed to adjust stock",details:e.message},{status:500})}finally{t.release()}}[r,n]=i.then?(await i)():i,e.s(["POST",()=>l]),a()}catch(e){a(e)}},!1),45944,e=>e.a(async(t,a)=>{try{var s=e.i(47909),r=e.i(74017),n=e.i(96250),o=e.i(59756),i=e.i(61916),d=e.i(14444),u=e.i(37092),l=e.i(69741),c=e.i(16795),p=e.i(87718),m=e.i(95169),_=e.i(47587),y=e.i(66012),R=e.i(70101),E=e.i(26937),h=e.i(10372),g=e.i(93695);e.i(52474);var k=e.i(220),f=e.i(46534),$=t([f]);[f]=$.then?(await $)():$;let S=new s.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/stock/adjust/route",pathname:"/api/stock/adjust",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/stock/adjust/route.ts",nextConfigOutput:"standalone",userland:f}),{workAsyncStorage:C,workUnitAsyncStorage:v,serverHooks:T}=S;function A(){return(0,n.patchFetch)({workAsyncStorage:C,workUnitAsyncStorage:v})}async function w(e,t,a){S.isDev&&(0,o.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let s="/api/stock/adjust/route";s=s.replace(/\/index$/,"")||"/";let n=await S.prepare(e,t,{srcPage:s,multiZoneDraftMode:!1});if(!n)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:f,params:$,nextConfig:A,parsedUrl:w,isDraftMode:C,prerenderManifest:v,routerServerContext:T,isOnDemandRevalidate:b,revalidateOnlyGenerated:N,resolvedPathname:O,clientReferenceManifest:x,serverActionsManifest:j}=n,M=(0,l.normalizeAppPath)(s),q=!!(v.dynamicRoutes[M]||v.routes[O]),I=async()=>((null==T?void 0:T.render404)?await T.render404(e,t,w,!1):t.end("This page could not be found"),null);if(q&&!C){let e=!!v.routes[O],t=v.dynamicRoutes[M];if(t&&!1===t.fallback&&!e){if(A.experimental.adapterPath)return await I();throw new g.NoFallbackError}}let L=null;!q||S.isDev||C||(L=O,L="/index"===L?"/":L);let P=!0===S.isDev||!q,U=q&&!P;j&&x&&(0,d.setReferenceManifestsSingleton)({page:s,clientReferenceManifest:x,serverActionsManifest:j,serverModuleMap:(0,u.createServerModuleMap)({serverActionsManifest:j})});let F=e.method||"GET",H=(0,i.getTracer)(),D=H.getActiveScopeSpan(),K={params:$,prerenderManifest:v,renderOpts:{experimental:{authInterrupts:!!A.experimental.authInterrupts},cacheComponents:!!A.cacheComponents,supportsDynamicResponse:P,incrementalCache:(0,o.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:A.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,s)=>S.onRequestError(e,t,s,T)},sharedContext:{buildId:f}},B=new c.NodeNextRequest(e),W=new c.NodeNextResponse(t),V=p.NextRequestAdapter.fromNodeNextRequest(B,(0,p.signalFromNodeResponse)(t));try{let n=async e=>S.handle(V,K).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=H.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==m.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let r=a.get("next.route");if(r){let t=`${F} ${r}`;e.setAttributes({"next.route":r,"http.route":r,"next.span_name":t}),e.updateName(t)}else e.updateName(`${F} ${s}`)}),d=!!(0,o.getRequestMeta)(e,"minimalMode"),u=async o=>{var i,u;let l=async({previousCacheEntry:r})=>{try{if(!d&&b&&N&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await n(o);e.fetchMetrics=K.renderOpts.fetchMetrics;let i=K.renderOpts.pendingWaitUntil;i&&a.waitUntil&&(a.waitUntil(i),i=void 0);let u=K.renderOpts.collectedTags;if(!q)return await (0,y.sendResponse)(B,W,s,K.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,R.toNodeOutgoingHttpHeaders)(s.headers);u&&(t[h.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==K.renderOpts.collectedRevalidate&&!(K.renderOpts.collectedRevalidate>=h.INFINITE_CACHE)&&K.renderOpts.collectedRevalidate,r=void 0===K.renderOpts.collectedExpire||K.renderOpts.collectedExpire>=h.INFINITE_CACHE?void 0:K.renderOpts.collectedExpire;return{value:{kind:k.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:r}}}}catch(t){throw(null==r?void 0:r.isStale)&&await S.onRequestError(e,t,{routerKind:"App Router",routePath:s,routeType:"route",revalidateReason:(0,_.getRevalidateReason)({isStaticGeneration:U,isOnDemandRevalidate:b})},T),t}},c=await S.handleResponse({req:e,nextConfig:A,cacheKey:L,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:v,isRoutePPREnabled:!1,isOnDemandRevalidate:b,revalidateOnlyGenerated:N,responseGenerator:l,waitUntil:a.waitUntil,isMinimalMode:d});if(!q)return null;if((null==c||null==(i=c.value)?void 0:i.kind)!==k.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(u=c.value)?void 0:u.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});d||t.setHeader("x-nextjs-cache",b?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),C&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,R.fromNodeOutgoingHttpHeaders)(c.value.headers);return d&&q||p.delete(h.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,E.getCacheControlHeader)(c.cacheControl)),await (0,y.sendResponse)(B,W,new Response(c.value.body,{headers:p,status:c.value.status||200})),null};D?await u(D):await H.withPropagatedContext(e.headers,()=>H.trace(m.BaseServerSpan.handleRequest,{spanName:`${F} ${s}`,kind:i.SpanKind.SERVER,attributes:{"http.method":F,"http.target":e.url}},u))}catch(t){if(t instanceof g.NoFallbackError||await S.onRequestError(e,t,{routerKind:"App Router",routePath:M,routeType:"route",revalidateReason:(0,_.getRevalidateReason)({isStaticGeneration:U,isOnDemandRevalidate:b})}),q)throw t;return await (0,y.sendResponse)(B,W,new Response(null,{status:500})),null}}e.s(["handler",()=>w,"patchFetch",()=>A,"routeModule",()=>S,"serverHooks",()=>T,"workAsyncStorage",()=>C,"workUnitAsyncStorage",()=>v]),a()}catch(e){a(e)}},!1)];

//# sourceMappingURL=_e3ddcb9d._.js.map